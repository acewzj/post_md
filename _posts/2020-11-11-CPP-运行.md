---
title:  "一个程序在计算机中到底是如何运行的"
date:   2019-07-20 10:16:18 +0800
categories:
- Data_Structure
tags:
- DS
---

这篇文章记述了关于程序编译的知识点。

<!--more-->





## C语言内存模型及运行时内存布局

![](https://i.loli.net/2019/09/06/DXrJUICwidhme6s.png)

 

##  Linux下C语言程序的内存布局

程序内存在地址空间中的分布情况称为内存模型（Memory Model）。内存模型由操作系统构建，在Linux和Windows下有所差异，并且会受到编译模式的影响，本节我们讲解Linux下32位环境和64位环境的内存模型。

## 内核空间和用户空间

对于32位环境，理论上程序可以拥有 4GB 的虚拟地址空间，我们在C语言中使用到的变量、函数、字符串等都会对应内存中的一块区域。

但是，在这 4GB 的地址空间中，要拿出一部分给操作系统内核使用，应用程序无法直接访问这一段内存，这一部分内存地址被称为内核空间（Kernel Space）。

Windows 在默认情况下会将高地址的 2GB 空间分配给内核（也可以配置为1GB），而 Linux 默认情况下会将高地址的 1GB 空间分配给内核。也就是说，应用程序只能使用剩下的 2GB 或 3GB 的地址空间，称为用户空间（User Space）。

## Linux下32位环境的用户空间内存分布情况

我们暂时不关心内核空间的内存分布情况，下图是Linux下32位环境的一种经典内存模型：

![image-20200330162632564](https://i.loli.net/2020/04/06/3n2W4uPtqcKsfUT.png)


对各个内存分区的说明：

| 内存分区                 | 说明                                                         |
| ------------------------ | ------------------------------------------------------------ |
| 程序代码区 (code)        | 存放函数体的二进制代码。一个C语言程序由多个函数构成，C语言程序的执行就是函数之间的相互调用。 |
| 常量区 (constant)        | 存放一般的常量、字符串常量等。这块内存只有读取权限，没有写入权限，因此它们的值在程序运行期间不能改变。 |
| 全局数据区 (global data) | 存放全局变量、静态变量static等。这块内存有读写权限，因此它们的值在程序运行期间可以任意改变。 |
| 堆区 (heap)              | 一般由程序员分配和释放，若程序员不释放，程序运行结束时由操作系统回收。malloc()、calloc()、free() 等函数操作的就是这块内存，这也是本章要讲解的重点。  注意：这里所说的堆区与数据结构中的堆不是一个概念，堆区的分配方式倒是类似于链表。 |
| 动态链接库               | 用于在程序运行期间加载和卸载动态链接库。                     |
| 栈区 (stack)             | 存放函数的参数值、局部变量的值等，其操作方式类似于数据结构中的栈。 |

<u>在C语言的程序中，对变量的使用还有以下注意</u>：

1.在函数体中定义的变量通常是在栈上，不需要在程序中进行管理，由编译器处理。

2.用malloc，calloc,realoc等分配分配内存的函数所分配的内存空间在堆上，程序必须保证在使用后使用后free 释放，否则会发生内存泄漏。

3.所有函数体外定义的是全局变量，加了static修饰符后的变量不管在函数内部或者外部存放在全局区（静态区）。

**4.使用const定义的变量将放于程序的只读数据区。**

说明：

在C语言中，可以定义static变量：在函数体内定义的static变量只能在该函数体内有效；在所有函数体外定义的static变量，也只能在该文件中有效，不能在其他源文件中使用；对于没有使用static修饰的全局变量，可以在其他的源文件中使用。这些区别是编译的概念，即如果不按要求使用变量，编译器会报错。使用static 和没使用static修饰的全局变量最终都将放置在程序的全局去（静态去）。
*这里我有一个问题：如果形参是Constant常量，那么是将它分配到常量区还是堆栈呢？分配到常量区不太可能，因为常量区是编译时就已经确定好的，不能再动态的添加常量了，如果分配到堆栈又怎么能保证它是一个常量呢？*

在这些内存分区中（暂时不讨论动态链接库），程序代码区用来保存指令，常量区、全局数据区、堆、栈都用来保存数据。对内存的研究，重点是对数据分区的研究。

程序代码区、常量区、全局数据区在程序加载到内存后就分配好了，并且在程序运行期间一直存在，不能销毁也不能增加（大小已被固定），只能等到程序运行结束后由操作系统收回，所以全局变量、字符串常量等在程序的任何地方都能访问，因为它们的内存一直都在。

> 常量区和全局数据区有时也被合称为静态数据区，意思是这段内存专门用来保存数据，在程序运行期间一直存在。

函数被调用时，会将参数、局部变量、返回地址等与函数相关的信息压入栈中，函数执行结束后，这些信息都将被销毁。所以局部变量、参数只在当前函数中有效，不能传递到函数外部，因为它们的内存不在了。

常量区、全局数据区、栈上的内存由系统自动分配和释放，不能由程序员控制。程序员唯一能控制的内存区域就是堆（Heap）：它是一块巨大的内存空间，常常占据整个虚拟空间的绝大部分，在这片空间中，程序可以申请一块内存，并自由地使用（放入任何数据）。堆内存在程序主动释放之前会一直存在，不随函数的结束而失效。在函数内部产生的数据只要放到堆中，就可以在函数外部使用。

## 一个实例

为了加深对内存布局的理解，请大家看下面一段代码：

```c
#include <stdio.h>
char *str1 = "c.net";  //字符串在常量区，str1在全局数据区
int n;  //全局数据区
char* func(){
    char *str = "C语言";  //字符串在常量区，str在栈区
    return str;
}
int main(){
    int a;  //栈区
    char *str2 = "01234";  //字符串在常量区，str2在栈区
    char  arr[20] = "56789";  //字符串和arr都在栈区
    char *pstr = func();  //栈区
    int b;  //栈区
    printf("str1: %#X\npstr: %#X\nstr2: %#X\n", str1, pstr, str2);
    puts("--------------");
    printf("&str1: %#X\n   &n: %#X\n", &str1, &n);
    puts("--------------");
    printf("  &a: %#X\n arr: %#X\n  &b: %#X\n", &a, arr, &b);
    puts("--------------");
    printf("n: %d\na :%d\nb: %d\n", n, a, b);
    puts("--------------");
    printf("%s\n", pstr);
    return 0;
}
```

运行结果：

```c
str1: 0X400710
pstr: 0X400720
str2: 0X400731
--------------
&str1: 0X601040
   &n: 0X60104C
--------------
 &a: 0X19D0728C
arr: 0X19D07270
 &b: 0X19D0726C
--------------
n: 0
a: -858993460
b: -858993460
--------------
C语言
```

  对代码的说明：
1) 全局变量的内存在编译时就已经分配好了，它的默认初始值是 0（它所占用的每一个字节都是0值），局部变量的内存在函数调用时分配，它默认初始值是不确定的，由编译器决定，一般是垃圾值，这在详细分析一个函数进栈出栈的例子中会详细讲解。

2) 函数 func() 中的局部字符串常量`"C语言"`也被存储到常量区，不会随着 func() 的运行结束而销毁，所以最后依然能够输出。

3) 字符数组 arr[20] 在栈区分配内存，字符串`"56789"`就保存在这块内存中，而不是在常量区，大家要注意区分。  

# Windows下C语言程序的内存布局

在32位环境下，Windows 默认会将高地址的 2GB 空间分配给内核（也可以配置为1GB），而将剩下的 2GB 空间分配给用户程序。

不像 Linux，Windows 是闭源的，有版权保护，资料较少，不好深入研究每一个细节，至今仍有一些内部原理不被大家知晓。关于 Windows 地址空间的内存分布，官网上只给出了简单的说明：

- 对于32位程序，内核占用较高的 2GB，剩下的 2GB 分配给用户程序；
- 对于64位程序，内核占用最高的 248TB，用户程序占用最低的 8TB。


下图是一个典型的 Windows 32位程序的内存分布：

![image-20200330162558813](https://i.loli.net/2020/04/06/zn6bMAG4lXkPpTD.png)

  可以看到，Windows 的地址空间被分配给了各种 exe、dll 文件、堆、栈。其中 exe 文件一般位于 0x00400000 起始的地址；一部分 DLL 位于 0x10000000 起始的地址，如运行库 dll；还有一部分 DLL 位于接近 0x80000000 的位置，如系统 dll，Ntdll.dll、Kernel32.dll。

栈的位置则在 0x00030000 和 exe 文件后面都有分布，可能有读者奇怪为什么 Windows 需要这么多栈呢？我们知道，每个线程的栈都是独立的，所以一个进程中有多少个线程，就有多少个对应的栈，对于 Windows 来说，每个线程默认的栈大小是 1MB。

在分配完上面这些地址以后，Windows 的地址空间已经是支离破碎了。当程序向系统申请堆空间时，只好从这些剩下的还有没被占用的地址上分配。  

# 内核模式和用户模式

  首先我们要解释一个概念——进程（Process）。简单来说，一个可执行程序就是一个进程，前面我们使用C语言编译生成的程序，运行后就是一个进程。进程最显著的特点就是拥有独立的地址空间。

严格来说，程序是存储在磁盘上的一个文件，是指令和数据的集合，是一个静态的概念；进程是程序加载到内存运行后一系列的活动，是一个动态的概念。

前面我们在讲解地址空间时，一直说“程序的地址空间”，这其实是不严谨的，应该说“进程的地址空间”。一个进程对应一个地址空间，而一个程序可能会创建多个进程。  

内核空间存放的是操作系统内核代码和数据，是被所有程序共享的，在程序中修改内核空间中的数据不仅会影响操作系统本身的稳定性，还会影响其他程序，这是非常危险的行为，所以操作系统禁止用户程序直接访问内核空间。

要想访问内核空间，必须借助操作系统提供的 API 函数，执行内核提供的代码，让内核自己来访问，这样才能保证内核空间的数据不会被随意修改，才能保证操作系统本身和其他程序的稳定性。

用户程序调用系统 API 函数称为系统调用（System Call）；发生系统调用时会暂停用户程序，转而执行内核代码（内核也是程序），访问内核空间，这称为内核模式（Kernel Mode）。

用户空间保存的是应用程序的代码和数据，是程序私有的，其他程序一般无法访问。当执行应用程序自己的代码时，称为用户模式（User Mode）。

计算机会经常在内核模式和用户模式之间切换：

- 当运行在用户模式的应用程序需要输入输出、申请内存等比较底层的操作时，就必须调用操作系统提供的 API 函数，从而进入内核模式；
- 操作完成后，继续执行应用程序的代码，就又回到了用户模式。


总结：用户模式就是执行应用程度代码，访问用户空间；内核模式就是执行内核代码，访问内核空间（当然也有权限访问用户空间）。

## 为什么要区分两种模式

我们知道，内核最主要的任务是管理硬件，包括显示器、键盘、鼠标、内存、硬盘等，并且内核也提供了接口（也就是函数），供上层程序使用。当程序要进行输入输出、分配内存、响应鼠标等与硬件有关的操作时，必须要使用内核提供的接口。但是用户程序是非常不安全的，内核对用户程序也是充分不信任的，当程序调用内核接口时，内核要做各种校验，以防止出错。

从 Intel 80386 开始，出于安全性和稳定性的考虑，CPU 可以运行在 ring0 ~ ring3 四个不同的权限级别，也对数据提供相应的四个保护级别。不过 Linux 和 Windows 只利用了其中的两个运行级别：

- 一个是内核模式，对应 ring0 级，操作系统的核心部分和设备驱动都运行在该模式下。
- 另一个是用户模式，对应 ring3 级，操作系统的用户接口部分（例如 Windows API）以及所有的用户程序都运行在该级别。

## 为什么内核和用户程序要共用地址空间

既然内核也是一个应用程序，为何不让它拥有独立的4GB地址空间，而是要和用户程序共享、占用有限的内存呢？

让内核拥有完全独立的地址空间，就是让内核处于一个独立的进程中，这样每次进行系统调用都需要切换进程。切换进程的消耗是巨大的，不仅需要寄存器进栈出栈，还会使CPU中的数据缓存失效、MMU中的页表缓存失效，这将导致内存的访问在一段时间内相当低效。

而让内核和用户程序共享地址空间，发生系统调用时进行的是模式切换，模式切换仅仅需要寄存器进栈出栈，不会导致缓存失效；现代CPU也都提供了快速进出内核模式的指令，与进程切换比起来，效率大大提高了。

# 栈的概念以及栈溢出 

在C语言程序的内存布局（内存模型）中我们讲到，程序的虚拟地址空间分为多个区域，栈（Stack）是其中地址较高的一个区域。栈（Stack）可以存放函数参数、局部变量、局部数组等作用范围在函数内部的数据，它的用途就是完成函数的调用。

栈内存由系统自动分配和释放：发生函数调用时就为函数运行时用到的数据分配内存，函数调用结束后就将之前分配的内存全部销毁。所以局部变量、参数只在当前函数中有效，不能传递到函数外部。

## 栈的概念

在计算机中，栈可以理解为一个特殊的容器，用户可以将数据依次放入栈中，然后再将数据按照相反的顺序从栈中取出。也就是说，先放入的数据最后才能取出，而最后放入的数据必须先取出。这称为先进后出（First In Last Out）原则。

放入数据常称为入栈或压栈（Push），取出数据常称为出栈或弹出（Pop）。如下图所示：

![image-20200330162457434](https://i.loli.net/2020/04/06/7xPHC4LKE9zshBY.png)
图：数据的出栈和入栈


可以发现，栈底始终不动，出栈入栈只是在移动栈顶，当栈中没有数据时，栈顶和栈底重合。

从本质上来讲，栈是一段连续的内存，需要同时记录栈底和栈顶，才能对当前的栈进行定位。在现代计算机中，通常使用`ebp`寄存器指向栈底，而使用`esp`寄存器指向栈顶。随着数据的进栈出栈，esp 的值会不断变化，进栈时 esp 的值减小，出栈时 esp 的值增大。

> ebp 和 esp 都是CPU中的寄存器：ebp 是 Extend Base Pointer 的缩写，通常用来指向栈底；esp 是 Extend Stack Pointer 的缩写，通常用来指向栈顶。

如下图所示是一个栈的实例：

![image-20200330162526230](https://i.loli.net/2020/04/06/iUTBEfR9WKjlNeL.png)

## 栈的大小以及栈溢出

对每个程序来说，栈能使用的内存是有限的，一般是 1M~8M，这在编译时就已经决定了，程序运行期间不能再改变。如果程序使用的栈内存超出最大值，就会发生栈溢出（Stack Overflow）错误。

> 一个程序可以包含多个线程，每个线程都有自己的栈，严格来说，栈的最大值是针对线程来说的，而不是针对程序。

栈内存的大小和编译器有关，编译器会为栈内存指定一个最大值，在 VC/VS 下，默认是 1M，在 C-Free 下，默认是 2M，在 Linux GCC 下，默认是 8M。

当然，我们也可以通过参数来修改栈内存的大小。以 VS2010 为例，在工程名处右击，会弹出一个菜单，选择“属性”，会出现一个对话框，如下图所示：

![image-20200330162741103](https://i.loli.net/2020/04/06/j3OQhXps6Bf48Rt.png)


该图中，我们将栈内存设置为 4M。提示：栈也经常被称为堆栈，而堆依然称为堆，所以堆栈这个概念并不包含堆，大家要注意区分。

当程序使用的栈内存大于默认值（或者修改后的值）时，就会发生栈溢出（Stack Overflow）错误。使用 VS2010 并切换到 Debug 模式，运行如下的代码：

```c
int main(){
   char str[1024*1024*2] = {0};
   return 0;
 }
```

局部字符数组 str 存储在栈上，占用 2M 的内存，超出了默认值 1M，所以会发生栈溢出错误，如下图所示：

![image-20200330162804520](https://i.loli.net/2020/04/06/cSJn6eT4MkGozyt.png)

# c语言入门-一个函数在栈上到底是怎样的



函数的调用和栈是分不开的，没有栈就没有函数调用，本节就来讲解函数在栈上是如何被调用的。

## 栈帧/活动记录

当发生函数调用时，会将函数运行需要的信息全部压入栈中，这常常被称为栈帧（Stack Frame）或活动记录（Activate Record）。活动记录一般包括以下几个方面的内容：

1) 函数的返回地址，也就是函数执行完成后从哪里开始继续执行后面的代码。例如：

```c
  int a, b, c;
  func(1, 2);
  c = a + b;
```

站在C语言的角度看，func() 函数执行完成后，会继续执行`c=a+b;`语句，那么返回地址就是该语句在内存中的位置。

> 注意：C语言代码最终会被编译为机器指令，确切地说，返回地址应该是下一条指令的地址，这里之所以说是下一条C语言语句的地址，仅仅是为了更加直观地说明问题。

2) 参数和局部变量。有些编译器，或者编译器在开启优化选项的情况下，会通过寄存器来传递参数，而不是将参数压入栈中，我们暂时不考虑这种情况。

3) 编译器自动生成的临时数据。例如，当函数返回值的长度较大（比如占用40个字节）时，会先将返回值压入栈中，然后再交给函数调用者。

> 当返回值的长度较小（char、int、long 等）时，不会被压入栈中，而是先将返回值放入寄存器，再传递给函数调用者。

4) 一些需要保存的寄存器，例如 ebp、ebx、esi、edi 等。之所以要保存寄存器的值，是为了在函数退出时能够恢复到函数调用之前的场景，继续执行上层函数。

下图是一个函数调用的实例：

![image-20200330162839836](https://i.loli.net/2020/04/06/rI4k3wV1ah7Lfqj.png)


上图是在Windows下使用VS2010 Debug模式编译时一个函数所使用的栈内存，可以发现，理论上 ebp 寄存器应该指向栈底，但在实际应用中，它却指向了old ebp。

> 在寄存器名字前面添加“old”，表示函数调用之前该寄存器的值。

当发生函数调用时：

- 实参、返回地址、ebp 寄存器首先入栈；
- 然后再分配一块内存供局部变量、返回值等使用，这块内存一般比较大，足以容纳所有数据，并且会有冗余；
- 最后将其他寄存器的值压入栈中。


需要注意的是，不同编译器在不同编译模式下所产生的函数栈并不完全相同，例如在VS2010下选择Release模式，编译器会进行大量优化，函数栈的样貌荡然无存，不具有教学意义，所以本教程以VS2010 Debug模式为例进行分析。

## 关于数据的定位

由于 esp 的值会随着数据的入栈而不断变化，要想根据 esp 找到参数、局部变量等数据是比较困难的，所以在实现上是根据 ebp 来定位栈内数据的。ebp 的值是固定的，数据相对 ebp 的偏移也是固定的，ebp 的值加上偏移量就是数据的地址。

例如一个函数的定义如下：

```c
  void func(int a, int b){
      float f = 28.5;
      int n = 100;
      //TODO:
  }
```

调用形式为：

```c
func(15, 92);
```

那么函数的活动记录如下图所示：

![image-20200330162918960](https://i.loli.net/2020/04/06/FSNqYIxo28XD1W7.png)


这里我们假设两个局部变量挨着，并且第一个变量和 old ebp 也挨着（实际上它们之间有4个字节的空白），如此，第一个参数的地址是 ebp+12，第二个参数的地址是 ebp+8，第一个局部变量的地址是 ebp-4，第二个局部变量的地址是 ebp-8。

#  c语言入门-函数调用惯例（Calling Convention） 



我们知道，一个C程序由若干个函数组成，C程序的执行实际上就是函数之间的相互调用。请看下面的代码：

```c
  #include <stdio.h>
   void funcA(int m, int n){
      printf("funcA被调用\n");
  }
  void funcB(float a, float b){
      funcA(100, 200);
      printf("funcB被调用\n");
  }
  int main(){
      funcB(19.9, 28.5);
      printf("main被调用\n");
      return 0;
  }
```

main() 调用了 funcB()，funcB() 又调用了 funcA()。对于main() 调用 funcB()，我们称 main() 是调用方，funcB() 是被调用方；同理，对于 funcB() 调用 funcA()，funcB() 是调用方，funcA() 是被调用方。

函数的参数（实参）由调用方压入栈中供被调用方使用，它们之间要有一致的约定。例如，参数是从左到右入栈还是从右到左入栈，如果双方理解不一致，被调用方使用参数时就会出错。

以 funcB() 为例，假设 main() 函数先将 19.9 入栈，后将 28.5 入栈，但是 funcB() 在使用这些实参时却认为 28.5 先入栈，19.9 后入栈，那么就一定会产生混乱，误以为19.9 是传递给 b、28.5 是传递给 a 的。

所以，函数调用方和被调用方必须遵守同样的约定，理解要一致，这称为调用惯例（Calling Convention）。

一个调用惯例一般规定以下两方面的内容：
1) 函数参数的传递方式，是通过栈传递还是通过寄存器传递（这里我们只讲解通过栈传递的情况）。

2) 函数参数的传递顺序，是从左到右入栈还是从右到左入栈。

3) 参数弹出方式。函数调用结束后需要将压入栈中的参数全部弹出，以使得栈在函数调用前后保持一致。这个弹出的工作可以由调用方来完成，也可以由被调用方来完成。

4) 函数名修饰方式。函数名在编译时会被修改，调用惯例可以决定如何修改函数名。

在C语言中，存在多种调用惯例，可以在函数声明或函数定义时指定，例如：

```c
   #include <stdio.h>
   int __cdecl max(int m, int n);
   int main(){
       int a = max(10, 20);
      printf("a = %d\n", a);
      return 0;
  }
  int __cdecl max(int m, int n){
      int max = m>n ? m : n;
      return max;
  }
```

函数调用惯例在函数声明和函数定义时都可以指定，语法格式为：

返回值类型  调用惯例  函数名(函数参数)

在函数声明处是为调用方指定调用惯例，而在函数定义处是为被调用方（也就是函数本身）指定调用惯例。

`__cdecl`是C语言默认的调用惯例，在平时编程中，我们其实很少去指定调用惯例，这个时候就使用默认的 __cdecl。

> 注意：__cdecl 并不是标准关键字，上面的写法在 VC/VS 下有效，但是在 GCC 下，要使用 __attribute__((cdecl))。

除了 cdecl，还有其他调用惯例，请看下表：

| 调用惯例 | 参数传递方式                                            | 参数出栈方式          | 名字修饰                                                     |
| -------- | ------------------------------------------------------- | --------------------- | ------------------------------------------------------------ |
| cdecl    | 按照从右到左的顺序入栈                                  | 调用方                | 下划线+函数名， 如函数 max() 的修饰名为 _max                 |
| stdcall  | 按照从右到左的顺序入栈                                  | 函数本身 （被调用方） | 下划线+函数名+@+参数的字节数， 如函数 int max(int m, int n) 的修饰名为 _max_@8 |
| fastcall | 将部分参数放入寄存器， 剩下的参数按照从右到左的顺序入栈 | 函数本身 （被调用方） | @+函数名+@+参数的字节数                                      |
| pascal   | 按照从左到右的顺序入栈                                  | 函数本身 （被调用方） | 较为复杂，这里不再展开讨论                                   |



## stdafx

stdafx的英文全称为：Standard Application Framework Extensions（标准应用程序框架的扩展）。

所谓头文件[预编译](https://baike.baidu.com/item/预编译)，就是把一个工程(Project)中使用的一些MFC标准头文件(如Windows.H、Afxwin.H)预先编译，以后该工程编译时，不再编译这部分头文件，仅仅使用预编译的结果。这样可以加快编译速度，节省时间。

## inline

内联inline是给编译器的优化提示，如果一个函数被编译成inline的话，那么就会把函数里面的代码直接插入到调用这个函数的地方，而不是用调用函数的形式。如果函数体代码很短的话，这样会比较有效率，因为调用函数的过程也是需要消耗资源的。但是你inline只是给编译器的提示，编译器会根据实际情况自己决定到底要不要进行内联，如果函数过大、有函数指针指向这个函数或者有递归的情况下编译器都不会进行内联。

## 二维数组

/*

一维数组指针的使用

uint8 picture[];

picture即为picture[]的首地址  picture+1为picture[1]的地址

*picture+1等价于picture[1]    以此类推//指针运算优先级最高，即这个地方有错误*picture+1等价于picture[0]+1

![1576647715204](https://i.loli.net/2020/03/30/b2vMCUZNYPJSka6.png)

```c
int main(int argc, char* argv[])

{

    char a[8]={0};

    int b[3]={0};

    printf("十六进制地址%p", a);

    printf("十六进制地址%p", b);

    printf("十六进制地址%p", &a[0]);

    printf(" 十六进制地址%p", &b[0]);

     //printf("Hello World!\n");

    return 0;

}
```

 ![1576647767776](https://i.loli.net/2020/03/30/stIHdUEQcAO1aCP.png)





关于二维数组指针的使用

uint8 picture[][16];

picture即为picture[][]的首地址  picture[0][0]的地址     picture+1为picture[0][1]的地址 以此类推

*picture为picture[0]的首地址      picture[0][0]的地址     *picture+1为picture[1][0]的地址 以此类推

现在结合一下：

*picture看成 *(picture+0)+0       *(picture+y)+x  就是picture[y][x]的地址   

如果我们此时再加一个'*'   会产生以下效果*(*(picture+y)+x)等价于picture[y][x]





 int a[][3]={4,4,4,4,4,4,4,4};

​    int b[3]={0};



​         printf("十六进制地址%p\n", a);



​         printf("十六进制地址%p\n", a+1);

![1576647805308](https://i.loli.net/2020/03/30/ogwZvPOcJ8i35Fd.png)

## C/C++混合编程

本篇文章是对C/C++混合编程进行了详细的分析介绍，需要的朋友参考下。

​        在工作中，C、C++密不可分，做我们嵌入式方面的，当然更多的是C，但，有时候却少不了C++，而且是C、C++混搭（混合编程）在一起的，比如，RTP视频传输，live555多媒体播放等都是C++下的，他需要调用JRTPLIB库，再比如，我那邮件发送，我也用C++写的，定义了一个Email对象，包含了成员：收发邮件地址，用户名，密码等，以及方法：邮件头、Base64编码和邮件发送这些操作，很好用，所以，很多时候，C++还是蛮不错的。。。。但，*.c与*.cpp文件混搭在一起，不是那么的简单，知识总是：用时方恨少啊！！！现在，我们就来慢慢的了解吧。

**一、extern“C”的作用（最重点）**

​    **1. extern "C"的真实目的是实现类C和C++的混合编程**。**extern “C”是由Ｃ＋＋提供的一个连接交换指定符号，用于告诉Ｃ＋＋这段代码是Ｃ函数**。**extern “C”后面的函数不使用的C++的名字修饰,而是用C。**这是因为C++编译后库中函数名会变得很长，与C生成的不一致，造成Ｃ＋＋不能直接调用C函数。

​    **2.**C++语言支持函数重载，C语言不支持函数重载。函数被C++编译后在库中的名字与C语言的不同。假设某个函数的原型为：**void foo(int x, int y);**该函数被**C编译器编译**后在库中的名字为**_foo**，而**C++编译器**则会产生像**_foo_int_int之类**的名字。**C++提供了C连接交换指定符号extern“C”来解决名字匹配问题。**

​    **3.**被extern "C"限定的函数或变量是**extern类型**的；extern是C/C++语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用。被extern "C"修饰的变量和函数是按照C语言方式编译和连接的。   

​     **4.与extern对应的关键字是static**，被它修饰的全局变量和函数只能在本模块中使用。因此，一个函数或变量只可能被本模块使用时，其不可能被extern “C”修饰。

**二、extern“C”与__cplusplus**

**#ifdef __cplusplus        extern "C" {        #endif        #ifdef __cplusplus        }        #endif**

​    **Cplusplus（C plus plus）**即"C++"，**用于C++文档的头文件中**，上面代码的意思是：如果是C++文件（*.cpp）后缀，则使用extern “C”，在C++项目中应用的非常广泛。即使用gcc编译器编译，函数名为C类型如**_foo**。个人认为，搞懂了这两个关键字，尤其是理解extern "C"（再次强调，不为过，呵呵），接下来的**混合编程**也就差不多了，哈哈哈。。。。



# __declspec

CV_EXPORTS_W 实际上就是 __declspec（dllexport），查阅Google可以发现，其作用如下：

使用__declspec（dllexport）关键字从DLL导出数据、函数、类或类成员函数时，它会将导出指令添加到对象文件中，因此在指定的对象文件里不需要使用.def文件。若要导出类中的所有公共数据成员和成员函数，关键字必须出现在类名的左边。由于对名称修饰没有标准规范，因此导出函数的名称在不同的编译器版本中可能有所变化。如果使用 （CV_EXPORTS）__declspec（dllexport），仅当解决任何命名约定更改时才必须重新编译 DLL 和依赖 .exe 文件。（防止编译出错）

补充：动态链接库中定义有两种函数：导出函数（export function）和内部函数（internal function）。

导出函数可以被其它模块调用，内部函数在定义它们的DLL程序内部使用。

MFC提供的修饰符号_declspec（dllexport） 就是表示导出函数或变量。

模块定义文件（.DEF）是一个或多个用于描述DLL属性的模块语句组成的文本文件。



















<ruby> 窗口管理器 <rt> Windows Manager  </rt> </ruby>

<kbd>Ctrl</kbd>+<kbd>F9</kbd>



