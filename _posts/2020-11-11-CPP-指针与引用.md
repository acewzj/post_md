---
title: 指针与引用
tags:
  - CPP
  - Pointer
  - Reference
categories:
  - CPP
date: 2020-11-11 18:51:08
---

这篇文章记述了关于指针与引用的知识点。

<!--more-->

## 指针与引用

我们可以把引用理解成变量的别名。定义一个引用的时候，程序把该引用和它的初始值绑定在一起，而不是拷贝它。计算机必须**在声明r的同时就要对它初始化**，并且，r一经声明，就不可以再和其它对象绑定在一起了。

实际上，你也可以把引用看做是通过一个常量指针来实现的，它只能绑定到初始化它的对象上。

关于指针和引用的对比，可以参看<<more effective C++>>中的第一条条款，引用的一个优点是它一定不为空，因此相对于指针，它不用检查它所指对象是否为空，这增加了效率

```c
int a,b,*p,&r=a;//正确
r=3;//正确：等价于a=3
int &rr;//出错：引用必须初始化
p=&a;//正确：p中存储a的地址，即p指向a
*p=4;//正确：p中存的是a的地址，对a所对应的存储空间存入值4
p=&b//正确：p可以多次赋值，p存储b的地址
```

对于指针来说，它是一个地址，这个地址是一个数值，那么就意味这个数值可以为0(空指针)，也可以为其他，即指针可以不指向任何东西。

而对于引用来说，他是一个外号，外号一定是“某个存在物体”的外号，所以引用不能为空，即不能存在空引用。

![04697FE33645E5C85A94D6323FA06C38](https://i.loli.net/2020/04/08/7lte6FOTBSIavL3.png)

![1760A8239D9C4A766A9B79CEF1E16A47](https://i.loli.net/2020/04/08/lZPaOrdvR4u32UF.png)

引用既然是张大胖的一个别名--大胖，就不能再让这个别名大胖指代别的人了，不然的话，故人提起大胖，你给我找出一个王大胖？这样不对吧，，，所以我们可以认为引用是指针常量，int * const 

1.如果一个引用和一个东西（这里再次使用“东西”这个词）绑定，那么它就永远只能是这个东西的“别名”，不能再说“其他人”的“别名”，即引用本身不能修改。但是，我们可以通过引用来修改它所引用的东西的值。

2.引用声明时必须同时初始化 ，且必须用左值初始化。（左值：就是可以用&求地址的量，换言之，就是有确定地址的量，而不是所谓的临时量）

​    对这些特性大家是不是似曾相识呢？没错，这些特性和“本身是常量的指针”(int* const p)的特性一样。事实上，我们完全可以借用“本身是常量的指针”来理解甚至定义引用：

**引用是一个指向不可变的、被编译器自动解引用的指针，即，引用是一个被编译器自动解引用的“本身是常量的指针”。**

看下面的代码

```
int a = 10;
int &ra = a;
ra = 11;
```

   在上面的代码中，编译器将int &ra=a转化为int* const ra=&a,而将ra=11转化为* ra=11，将ra自动转化为*ra的过程，就是上面定义中所说的“自动解引用”。

很显然，const int &ra=a就相当于const int* const ra=&a了。

```c++
    int aaa = 3;
    int bbb = 6;
    int& rr = aaa;
    rr = bbb;//我本来想这里它会被修改为bbb的地址，结果它转化为*rr = bbb -->aaa = 6.
	rr = &bbb;//如果这么写会报错：不能将int *类型的值分配到int类型的实体
```

# 三大件 手写 string

```c
class myString{
public:
    myString(){};
    ~myString(){};
    myString& myString(myString& str) const
    {
        char* s = (char*) malloc(sizeof(str));
        strcpy(str, s);
        this.c_str = s;
        return this;
    };
    myString& operator = (myString& str) const
    {
        if(str == this)
            return this;
        delete this.c_str;
        char* s = (char*) malloc(sizeof(str));
        strcpy(str, s);
        this.c_str = s;
        return this;
    }
    
private:
    char* c_str;    
};
```

```c
class String
{
public:
	String(const char* str=NULL);//普通的构造函数
	String(const String& other); //拷贝构造函数
	~String();
	String& operate = (const String& other);//复制构造
private:
	char* m_data;//用于保存字符串
};
 
String::String(const char* str)
{
	if (str==NULL)
	{
		m_data = new char[1];
		*m_data = '\0';
	}
	else
	{
		int len = strlen(str);
		m_data = new char[len+1];
		strcpy(m_data, str);
	}
}
 
String::~String()
{
	if (m_data!=NULL)
	{
		delete[] m_data;
		m_data = NULL;
	}
}
 
String::String(const String & other)
{
	int len = strlen(other.m_data);
	m_data = new char[len + 1];
	strcpy(m_data, other.m_data);
}
 
String& String::operate = (const String & other)
{
	if (this==other)
	{
		return *this;
	}
	delete[] m_data;
	int len = strlen(other.m_data);
	m_data = new char[len + 1];
	strcpy(m_data, other.m_data);
	return *this;
}
```



```c
class myString{
public:
    myString(char* pData = nullptr);
    ~myString(void);
    myString(const myString& str) const
    {
        int length = strlen(str.m_pData);
        m_pData = new char[length + 1];
        strcpy(m_pData, str.m_pData);
    };
    myString& operator = (const myString& str) const
    {
        if(&str == this)
            return *this;
        delete[] this.m_pData;
        char* s = (char*) malloc(sizeof(str));
        strcpy(str, s);
        this.c_str = s;
        return *this;
    }
    
private:
    char* m_pData;    
};
```

![image-20201112202639313](https://i.loli.net/2020/11/12/e3VO9EQJpUMslkn.png)

