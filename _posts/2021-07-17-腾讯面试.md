---
title: 2021-07-17 腾讯字节面试
tags:
  - 面经
categories:
  - 面经
date: 2021-07-17 19:16:52
---

这篇文章记述了关于字节和腾讯提前批面试的知识点。

<!--more-->



字节和腾讯一上来先问实习项目，问用户随意产生一个token可以访问 metaserver 吗？ metaserver 怎么降低信息变更时的抖动啊（用减少负载，具体怎么减少也不知道：减少查数据库次数，使用缓存等）；长轮询怎么保证报文推送给对应的网关啊？感觉这块讲的不是很清楚，得仔细捋清楚了使劲拖面试官的时间才行，不然这块不拖住他就会跑去问基础去了；

问完项目就是聊计算机基础：

### 操作系统相关：

讲一下 malloc 的工作机制？

> 首先会扫描之前由 free() 释放的空闲内存块列表，找到尺寸大于或者等于要求的一块空闲内存。如果这一块内存和所要求的相当就返回内存块地址。若是一块较大的内存就对其进行分割，剩下的那块空闲内存保留在空闲列表里。如果空闲列表里没有足够大的空闲内存块，那么 malloc() 就会调用 sbrk() 以分配更多的内存。由于 sbrk() 是系统调用要陷入内核，为了减少对 sbrk() 的调用次数， malloc() 并未只是严格按照所需字节数来分配内存，而是以更大的幅度（虚拟内存页大小的倍数 4K）来增加 program break，并将超出部分置于空闲内存列表中。

malloc 分配会导致缺页中断吗？

> malloc 分配的是虚拟内存，会涉及到缺页中断。

打开一个文件的过程是什么样的？

> 要打开一个文件，会有文件名。操作系统根据文件名a，在系统文件打开表中查找。
>
> **第一种情况：**
>
> 如果文件a已经打开，则在进程文件打开表中为文件a分配一个表项，然后将该表项的指针指向系统文件打开表中和文件a对应的一项;
>
> 然后再PCB中为文件分配一个文件描述符fd，作为进程文件打开表项的指针,文件打开完成。
>
> **第二种情况：**
>
> 如果文件a没有打开，查看含有文件a信息的目录项是否在内存中，如果不在，将目录表装入到内存中，作为cache；
>
> 根据目录表中文件a对应项找到 inode 在磁盘中的位置；
>
> 将文件a的 inode 装入到内存中的Active inode中；
>
> 然后在系统文件打开表中为文件a增加新的一个表项，将表项的指针指向Active Inode中文件a的FCB；
>
> 然后在进程的文件打开表中分配新的一项，将该表项的指针指向系统文件打开表中文件a对应的表项；
>
> 然后在PCB中，为文件a分配一个文件描述符fd，作为进程文件打开表项的指针,文件打开完成。
> 
>
> ![image-20201101141440780](https://i.loli.net/2020/11/01/uchaCoSYPnHzWpE.png)

一个进程打开一个文件在写，另外一个进程打开同一个文件进行删除，这样可以删除吗？

> Linux中多进程环境下，打开同一个文件，当一个进程进行读写操作，如果另外一个进程删除了这个文件，那么读写该文件的进程会发生什么呢?
>
> 因为文件被删除了，读写进程发生异常?
> 正在读写的进程仍然正常读写，好像没有发生什么？
> 学操作系统原理的时候，我们知道，linux是通过link的数量来控制文件删除，只有当一个文件不存在任何link的时候，这个文件才会被删除。
>
> 而每个文件都会有2个link计数器i_count 和 i_nlink。i_count的意义是当前使用者的数量，也就是打开文件进程的个数。i_nlink的意义是介质连接的数量；或者可以理解为 i_count是内存引用计数器，i_nlink是硬盘引用计数器。再换句话说，当文件被某个进程引用时，i_count 就会增加；当创建文件的硬连接的时候，i_nlink 就会增加。
>
> 对于 rm 而言，就是减少 i_nlink。这里就出现一个问题，如果一个文件正在被某个进程调用，而用户却执行 rm 操作把文件删除了，会出现什么结果呢？
>
> 当用户执行 rm 操作后，ls 或者其他文件管理命令不再能够找到这个文件，但是进程却依然在继续正常执行，依然能够从文件中正确的读取内容。这是因为，rm 操作只是将 i_nlink 置为 0 了；由于文件被进程引用的缘故，i_count 不为 0，所以系统没有真正删除这个文件。i_nlink 是文件删除的充分条件，而 i_count 才是文件删除的必要条件。
>
> 基于以上只是，大家猜一下，如果在一个进程在打开文件写日志的时候，手动或者另外一个进程将这个日志删除，会发生什么情况？
>
> 虽然日志文件被删除了，但是有一个进程已经打开了那个文件，所以向那个文件中的写操作仍然会成功，数据仍然会提交。
>
> 下面，告诉大家如何恢复那个删除的文件。
>
> 例如，你删除了tcpdump.log，执行lsof | grep tcpdump.log，你应该能看到这样的输出：
>
> tcpdump 2864 tcpdump 4w REG 253,0 0 671457 /root/tcpdump.log (deleted)
>
> 然后：
>
> cp /proc/2864/fd/4 /root/tcpdump.log

### 网络相关：

四次挥手为什么是四次？三次不行吗？被动关闭方是个什么流程？FIN 报文代表什么意思？

> 我先开始以为是解释最后一次ACK 的必要性，结果他的意思是解释一下服务器为啥会有 close_wait 状态。其实就是讲服务器要等做完工作了才能给客户端发送 FIN 报文，这个报文的意思是 “我做完了”。由此引申出为啥要三次握手，两次不行吗？---两次的话会造成这样一种后果：客户端发送SYN请求给服务端，结果在网络中滞留了很长时间，到服务端的时候可能客户端都重新干别的事去了。这个时候服务端一接收到 SYN，赶紧给客户端发 SYN ACK，结果因为没有第三次握手，它不知道客户端此时已经不再需要连接了，然后服务端就傻傻的等到超时，这对宝贵的服务端资源来说是不可忍受的。所以会有三次握手的存在。2021-07-17写

一个 1M 大小的文件使用 TCP 协议传输到对端，分析下时间消耗的维度，怎么可以减少时间的消耗？

> 这块属于开放性的问题，不知道咋回答。只能从报文分片，三次握手，确认应答等维度进行回答。减少时间消耗的话，面试官说如果采用长连接可以省却三次握手，分片也可以减少时间。

HTTP 协议怎么保持长连接？知道哪几种 HTTP 协议版本？HTTP1.X 和 HTTP2.X 的区别，HTTP3 了解吗？

拥塞控制的算法

拥塞控制和流量控制的区别

### 数据库相关：



### 数据结构算法相关：

hashmap 同时多个线程进行写操作该怎么做？

### 设计题：

设计一个5秒钟的定时任务怎么设计？

### 分布式：





0718 字节二面

上来就问 C++ 

多态怎么体现的？

> 多态体现为静态多态和动态多态。静态多态是用模板和函数重载体现的；动态多态是利用虚函数体现的；
>
> 如果一个类有虚函数的话会在生成这个类的时候在这个类的头部添上一个虚函数表指针（运行时），这个指针指向虚函数表（编译时生成），虚函数表里会有虚函数的地址；当生成一个派生类的对象并把这个派生类的对象赋值给一个基类指针的时候，可以利用这个基类指针调用派生类的虚函数，从而实现动态的多态。

一个类在内存中是什么样子的？

> 这个我答的时候答的不是很全面，我只答出来了有父类的时候会包含父类的虚函数表指针，父类成员变量，自己的成员变量这种层次。
>
> 其实全面一点的应该加上类的成员函数在内存中只有一份。static数据成员属于类,该类的所有对象共享static数据成员，static数据成员存储在 **静态存储区**。

C++  指针数组和数组指针的区别？

> 我说的是指针数组类似main函数参数 char** argv那种，是一个存储字符串参数的指针的数组；
>
> 数组指针就是数组的首地址；

extern C 的作用?

>实现 C 和 C++ 的混合编程，因为 C++ 的函数在编译之后会进行名字修饰，这样和 C 生成的不一致，造成 C++ 不能直接调 C 函数。用了 extern 之后就是告诉编译器这段代码用 C 语言的编译规则进行编译，不带函数修饰。

内联函数的作用？平时在哪用过？

> 内联其实就是将这个函数在被调用的地方进行展开，省去了函数调用参数入栈出栈的调用开销。一般用在体积比较小的函数，类中的函数其实就是内联。

static 关键字的用法？

> 仔细看 static 章节。

malloc free new delete 讲一下区别？

> 

面试官说三面有点危险让好好准备一下，靠！

咋准备呢？从以下几个方面来复习一遍吧！

C++ 基础

https://www.cnblogs.com/webary/p/4754522.html

网络基础

操作系统基础

数据库基础

项目基础

## 一、第一范式

1NF是对属性的**`原子性`**，要求属性具有原子性，不可再分解；

> 表：字段1、 字段2(字段2.1、字段2.2)、字段3 ......

如学生（学号，姓名，性别，出生年月日），如果认为最后一列还可以再分成（出生年，出生月，出生日），它就不是一范式了，否则就是；

## 二、第二范式

2NF是对记录的**`唯一性`**，要求记录有唯一标识，即实体的唯一性，即**不存在部分依赖**；

> 表：学号、课程号、姓名、学分;

这个表明显说明了两个事务:学生信息, 课程信息;由于非主键字段必须依赖主键，这里**学分依赖课程号**，**姓名依赖与学号**，所以不符合二范式。

**可能会存在问题：**

- `数据冗余:`，每条记录都含有相同信息；
- `删除异常：`删除所有学生成绩，就把课程信息全删除了；
- `插入异常：`学生未选课，无法记录进数据库；
- `更新异常：`调整课程学分，所有行都调整。

**正确做法:**
学生：`Student`(学号, 姓名)；
课程：`Course`(课程号, 学分)；
选课关系：`StudentCourse`(学号, 课程号, 成绩)。

## 三、第三范式

3NF是对字段的**`冗余性`**，要求任何字段不能由其他字段派生出来，它要求字段没有冗余，即**不存在传递依赖**；

> 表: 学号, 姓名, 年龄, 学院名称, 学院电话

因为存在**依赖传递**: (学号) → (学生)→(所在学院) → (学院电话) 。

**可能会存在问题：**

- `数据冗余:`有重复值；
- `更新异常：`有重复的冗余信息，修改时需要同时修改多条记录，否则会出现**数据不一致的情况** 。

**正确做法：**

学生：(学号, 姓名, 年龄, 所在学院)；

学院：(学院, 电话)。


### 0720-

日志恢复

三范式

文件IO流程

map STL

HashMap 并发

### Hash 算法哪几种？怎么衡量好坏？

https://blog.csdn.net/wuheshi/article/details/64906715

哈希函数常见的构造方法有5种：

直接寻址法：取关键字或关键字的某个线性函数值为散列地址。即 或 ，其中  为常数（这种散列函数叫做自身函数）

数字分析法：假设关键字是以r为基的数，并且哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干数位组成哈希地址。

平方取中法：取关键字平方后的中间几位为哈希地址。通常在选定哈希函数时不一定能知道关键字的全部情况，取其中的哪几位也不一定合适，而一个数平方后的中间几位数和数的每一位都相关，由此使随机分布的关键字得到的哈希地址也是随机的。取的位数由表长决定。

折叠法：将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位）作为哈希地址。

随机数法

除留余数法：取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。即, 。不仅可以对关键字直接取模，也可在折叠法、平方取中法等运算之后取模。对p的选择很重要，一般取素数或m，若p选择不好，容易产生碰撞。注意，在使用除留余数法 H(key)=key Mod p (p≤m)时，对除数p的选择很重要，若p选的不好，则很容易产生同义词。一般，将p选为素数。

字符串哈希
在实际应用中最常遇到的问题是计算一个字符串的hash值，现有的用于计算字符串hash值的算法有很多，比如： DJB2 DJB2a (variant using xor rather than +) FNV-1 (32-bit) FNV-1a (32-bit) SDBM CRC32 Murmur2 (32-bit) SuperFastHash

注：这篇文章中详细介绍了常见的哈希算法：[General Purpose Hash Function Algorithms](http://blog.zheming.wang/post/technical/general-purpose-hash-function-algorithms)

注：这篇文章中详细介绍了各种常见的字符串哈希算法的性能对比：[Which hashing algorithm is best for uniqueness and speed](http://blog.zheming.wang/post/technical/which-hashing-algorithm-is-best-for-uniqueness-and-speed)

下面介绍两种使用最广泛的性能优良的字符串hash值计算方法：DJB Hash,Murmur Hash。Redis的字典实现中就使用了这两种哈希算法。 下面介绍两种使用最广泛的性能优良的字符串hash值计算方法：DJB Hash,Murmur Hash。Redis的字典实现中就使用了这两种哈希算法。

哈希函数处理冲突的方法常见的有2种：
　　a) 开放地址法
　　在该方法中，又细分为：线性探查法、平方探查法、伪随机数序列法、双哈希函数法等等。
　　b)拉链法
　　拉链法是把所有的同义词，用单链表链接起来的方法。在这种方法中，哈希表每个单元中存放的不再是记录本身，而是相应同义词单链表的头指针。

一致性hash算法提出了在动态变化的Cache环境中，判定哈希算法好坏的四个定义

1. 平衡性(Balance)：平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。
2. 单调性(Monotonicity)：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。
3. 分散性(Spread)：在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。
4. 负载(Load)：负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同 的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。





## 单例模式有两种类型：

- `懒汉式`：在真正需要使用对象时才去创建该单例类对象
- `饿汉式`：在类加载时已经创建好该单例对象，等待被程序使用

### 懒汉式创建单例对象

懒汉式创建对象的方法是在程序使用对象前，先判断该对象是否已经实例化（判空），若已实例化直接返回该类对象。否则则先执行实例化操作。

根据上面的流程图，就可以写出下面的这段代码

```java
public class Singleton {
    
    private static Singleton singleton;
    
    private Singleton(){}
    
    public static Singleton getInstance() {
        if (singleton == null) {
            singleton = new Singleton();
        }
        return singleton;
    }
    
}
```

没错，这里我们已经写出了一个很不错的单例模式，不过它不是完美的，但是这并不影响我们使用这个“单例对象”。

以上就是懒汉式创建单例对象的方法，我会在后面解释这段代码在哪里可以优化，存在什么问题。

### 饿汉式创建单例对象

饿汉式在`类加载`时已经创建好该对象，在程序调用时直接返回该单例对象即可，即我们在编码时就已经指明了要马上创建这个对象，不需要等到被调用时再去创建。

关于类加载，涉及到JVM的内容，我们目前可以简单认为在程序启动时，这个单例对象就已经创建好了。

## **读文件**

1、进程调用库函数向内核发起读文件请求；

2、内核通过检查进程的文件描述符定位到虚拟文件系统的已打开文件列表表项；

3、调用该文件可用的系统调用函数read()

3、read()函数通过文件表项链接到目录项模块，根据传入的文件路径，在目录项模块中检索，找到该文件的inode；

4、在inode中，通过文件内容偏移量计算出要读取的页；

5、通过inode找到文件对应的address_space；

6、在address_space中访问该文件的页缓存树，查找对应的页缓存结点：

（1）如果页缓存命中，那么直接返回文件内容；

（2）如果页缓存缺失，那么产生一个页缺失异常，创建一个页缓存页，同时通过inode找到文件该页的磁盘地址，读取相应的页填充该缓存页；重新进行第6步查找页缓存；

7、文件内容读取成功。

 

**写文件**

前5步和读文件一致，在address_space中查询对应页的页缓存是否存在：

6、如果页缓存命中，直接把文件内容修改更新在页缓存的页中。写文件就结束了。这时候文件修改位于页缓存，并没有写回到磁盘文件中去。

7、如果页缓存缺失，那么产生一个页缺失异常，创建一个页缓存页，同时通过inode找到文件该页的磁盘地址，读取相应的页填充该缓存页。此时缓存页命中，进行第6步。

8、一个页缓存中的页如果被修改，那么会被标记成脏页。脏页需要写回到磁盘中的文件块。有两种方式可以把脏页写回磁盘：

（1）手动调用sync()或者fsync()系统调用把脏页写回

（2）pdflush进程会定时把脏页写回到磁盘

同时注意，脏页不能被置换出内存，如果脏页正在被写回，那么会被设置写回标记，这时候该页就被上锁，其他写请求被阻塞直到锁释放。

## 2021-09-08 快手面试

1、git merge 和 git rebase 差别

2、自由存储区是什么

3、new 和 malloc 的关系

4、函数调用堆栈的底层原理 寄存器知道哪些？编译时函数名和地址对应关系存在哪里？

5、无锁实现

6、C++ 防止内存泄漏 大规模的时候怎么办？

7、如何只在栈上分配内存

8、struct 和 class 区别，struct 可以有 private 成员吗？

9、虚函数 static 占用空间

10、cgroup 限制 CPU 使用，CPU 负载100%怎么办？

## 2021-09-10 快手二面

1、一上来就是让写去除字符串的空格，空间复杂度为O（1），我写了一个erase函数的版本，他问我时间复杂度是多少？我说是O（n），他说不对，继续引导我erase函数是怎么做的？我说是删除一个元素后，后面的元素往前移动，这样的话其实时间复杂度是O（n^2）。然后他又让我写一个时间复杂度为O（n）的版本，我写了一个双指针，但是他并不满意。

2、接下来写了个非递归遍历二叉树的程序，这个倒是中规中矩。

3、然后智力题：n 个球组合成二叉树有几种情况？我直接不会

4、程序从编译到执行的全流程，涉及编译链接，虚拟内存，进程执行和pagecache，最后又问了函数调试时的原理。

5、部门是做java虚拟机优化的，很底层，期待能有三面

## 2021-09-16 快手三面

面试官迟到了半个小时，很亲切的叫我终结，一看就是经验十分丰富的老程序员。

1、上来就出题

> ​	``char buf[5] = { 0x12, 0x34, 0x56, 0x78 , 0x90};`
> ​	`auto a = * (short *) &buf[3];`
> ​	cout << * (short *)&buf[3] << endl;`

2、

```c
class A {
public:
	int a = 23;
	void print(int n) {		
		std::cout << a + n << std::endl;
	}
};
int main(int argc, char **argv) {
	((A*)0)->print(4);
}
// 是否会core掉？我掉进陷阱说会：这个对象没有新建就调用其方法，但是真实答案是不会core掉，因为this 指针是0，但是由于print方法并没有引用该对象的任何变量，所以不会造成访问异常，太阴险了。接下来他又问空指针一定会造成非法访问吗？我说会，其实答案是不一定。
```

3、1000万的元素找最大的10个，每次内存里只能最大放50个。建一个10个元素的堆，时间复杂度是 空间复杂度是

4、进程通信方法，采用socket的速率受啥影响？

5
