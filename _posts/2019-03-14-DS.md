---
title: 数据结构
date: 2019-03-15 08:06:58
tags:
- DS
---

本文主要关于数据结构，数据结构是指数据存储的组织方式。大致上分为线性表、栈（Stack）、队列、树（tree）、图（Map）。

<!--more-->

首先看一下什么是排列，什么是组合？

> 排列和组合的本质区别是：决策的顺序对结果有没有影响？
>
> 你一听排列，首先想到的就是排队，你站队头和站队尾那是两种排列；
>
> 例如  3 2 1  和 1 2 3 是两种排列
>
> 3！*2！ *1！
>
> 而组合对顺序无感，所以你站队头站队尾都是一种组合；
>
> 例如  3 2 1  和 1 2 3 是一种组合
>
> (3！* 2！ * 1！) / (3 * 2)
>
> “排列”类型问题和“子集、组合”问题不同在于：“排列”问题使用used数组来标识选择列表，而“子集、组合”问题则使用start参数

## 排列类问题

### 全排列

给定一个 没有重复 数字的序列，返回其所有可能的全排列。
输入: [1,2,3]
输出:
[
[1,2,3],
[1,3,2],
[2,1,3],
[2,3,1],
[3,1,2],
[3,2,1]
]

 ![image-20210221183551990](https://i.loli.net/2021/02/21/9qQXVjOnvgEyCGI.png)

首先，我们固定1，然后只有2、3可选：如果选2，那就只剩3可选，得出结果[1,2,3]；如果选3，那就只剩2可选，得出结果[1,3,2]。再来，如果固定2，那么只有1,3可选：如果选1，那就只剩3，得出结果[2,1,3].....
有没有发现一个规律：如果我们固定了(选择了)某个数，那么他的下一层的选择列表就是——除去这个数以外的其他数。比如，第一次选择了2，那么他的下一层的选择列表只有1和3；如果选择了3，那么他的下一层的选择列表只有1和2,那么这个时候就要引入一个used数组来记录使用过的数字。

 ```c
void backtrack(vector<int>& nums,vector<bool>&used,vector<int>& path)//used初始化为false
{
    if(path.size()==nums.size())
    {
        res.push_back(path);
        return;
    }
    for(int i=0;i<nums.size();i++)//从给定的数中除去，用过的数，就是当前的选择列表
    {
        if(!used[i])//如果没用过
        {
            path.push_back(nums[i]);//做选择
            used[i]=true;//设置当前数已用
            backtrack(nums,used,path);//进入下一层
            used[i]=false;//撤销选择
            path.pop_back();//撤销选择
        }
    }

}

作者：show-me-the-code-2
链接：https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-ga-4/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
 ```

给定一个**可包含重复数字**的序列，返回所有**不重复**的全排列。
输入: [1,2,2]
输出:
[
[1,2,2],
[2,1,2],
[2,2,1]
]

有了前面“子集、组合”问题的判重经验，同样首先要对题目中给出的nums数组排序，让重复的元素并列排在一起，在

`if(i>start&&nums[i] == nums[i-1])`，基础上修改为`if(i>0&&nums[i]==nums[i-1]&&!used[i-1])`，语义为：当i可以选第一个元素之后的元素时(因为如果i=0，即只有一个元素，哪来的重复？有重复即说明起码有两个元素或以上,i>0)，然后判断当前元素是否和上一个元素相同？如果相同，再判断上一个元素是否能用？如果三个条件都满足，那么该分支一定是重复的，应该剪去

 ```c
void backtrack(vector<int>& nums,vector<bool>&used,vector<int>& path)//used初始化全为false
{
    if(path.size()==nums.size())
    {
        res.push_back(path);
        return;
    }
    for(int i=0;i<nums.size();i++)//从给定的数中除去，用过的数，就是当前的选择列表
    {
        if(!used[i])
        {
            if(i>0&&nums[i]==nums[i-1]&&!used[i-1])//剪枝，三个条件
                continue;
            path.push_back(nums[i]);//做选择
            used[i]=true;//设置当前数已用
            backtrack(nums,used,path);//进入下一层
            used[i]=false;//撤销选择
            path.pop_back();//撤销选择
        }
    }
}

作者：show-me-the-code-2
链接：https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-ga-4/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
 ```



## 组合类问题

正好最近在担任组合数学的助教，刷的题目很多都跟组合有关。遂总结一下：

> 77.给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。
>
> 示例:
>
> 输入: n = 4, k = 2
> 输出:
> [
>   [2,4],
>   [3,4],
>   [2,3],
>   [1,2],
>   [1,3],
>   [1,4],
> ]

```c
class Solution {
private:
    vector<vector<int>> result; // 存放符合条件结果的集合
    vector<int> path; // 用来存放符合条件结果
    void backtracking(int n, int k, int startIndex) {
        if (path.size() == k) {
            result.push_back(path);
            return;
        }
        // 这个for循环有讲究，组合的时候 要用startIndex，排列的时候就要从0开始
        for (int i = startIndex; i <= n; i++) {//这个for是横向进行遍历
            path.push_back(i); // 处理节点 
            backtracking(n, k, i + 1);//这里是纵向进行dfs
            path.pop_back(); // 回溯，撤销处理的节点，这里是假如你找了两个，到了叶子节点，你需要回退成上一个状态
        }
    }
public:

    vector<vector<int>> combine(int n, int k) {
        backtracking(n, k, 1);
        return result;
    }
};
```

剪枝优化

在遍历的过程中如下代码 ：

`for (int i = startIndex; i <= n; i++) `
这个遍历的范围是可以剪枝优化的，怎么优化呢？

来举一个例子，n = 4， k = 4的话，那么从2开始的遍历都没有意义了。

已经选择的元素个数：`path.size();`

要选择的元素个数 : `k - path.size();`

在集合n中开始选择的起始位置 : `n - (k - path.size());`

因为起始位置是从1开始的，而且代码里是n <= 起始位置，所以 集合n中开始选择的起始位置 : n - (k - path.size()) + 1;

所以优化之后是：

`for (int i = startIndex; i <= n - (k - path.size()) + 1; i++)`

> 39.给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
>
> candidates 中的数字可以无限制重复被选取。
>
>  输入：candidates = [2,3,6,7], target = 7,
> 所求解集为：
> [
>   [7],
>   [2,2,3]
> ]

```c
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& candidates, int target, int sum, int startIndex) {
        if (sum > target) {
            return;
        }
        if (sum == target) {
            result.push_back(path);
            return;
        }

        // 这里i 依然从 startIndex开始，因为求的是组合，如果求的是排列，那么i每次都从0开始
        for (int i = startIndex; i < candidates.size(); i++) {
            sum += candidates[i];
            path.push_back(candidates[i]);
            backtracking(candidates, target, sum, i); // 关键点在这里，不用i+1了，表示可以重复读取当前的数
            sum -= candidates[i];
            path.pop_back();

        }
    }
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        backtracking(candidates, target, 0, 0);
        return result;
    }
};

```

## 手写：子集

> 很多同学在去重的问题上想不明白，其实很多题解也没有讲清楚，反正代码是能过的，感觉是那么回事，稀里糊涂的先把题目过了。
>
> 这个去重为什么很难理解呢，所谓去重，其实就是使用过的元素不能重复选取。 这么一说好像很简单！
>
> 都知道组合问题可以抽象为树形结构，那么“使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上使用过，一个维度是同一树层上使用过。没有理解这两个层面上的“使用过” 是造成大家没有彻底理解去重的根本原因。
>
> 那么问题来了，我们是要同一树层上使用过，还是统一树枝上使用过呢？
>
> 回看一下题目，元素在同一个组合内是可以重复的，怎么重复都没事，但两个组合不能相同。
>
> 所以我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重。
>
> 剧透一下，后期要讲解的排列问题里去重也是这个套路，所以理解“树层去重”和“树枝去重”非常重要。
>
> 用示例中的[1, 2, 2] 来举例，如图所示： （注意去重需要先对集合排序）

![image-20210331145211273](https://i.loli.net/2021/03/31/7JphUgsaMtBZObc.png)



```c
class Solution {
public:
    vector<int> path;
    vector<vector<int>> result;
    void backtrack(vector<int>& nums, vector<bool>& used, int startIndex) {
        result.push_back(path);
        for (int i = startIndex; i < nums.size(); ++i) {
            if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {
                continue;
            }
            path.push_back(nums[i]);
            used[i] = true;
            backtrack(nums, used, i + 1);
            used[i] = false;
            path.pop_back();
        }
    }
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        path.clear();
        result.clear();
        vector<bool> used(nums.size(), false);
        sort(nums.begin(), nums.end());
        backtrack(nums, used, 0);
        return result;
    }
};
```



## 最长重复子数组记住，子序列默认不连续，子数组默认连续

注意子数组和子序列的区别 如果是子序列的话 递推公式就是 ： dp[i][j] = max(dp[i-1][j-1]+(A[i-1] == B[j-1]?1:0),dp[i-1][j],dp[i][j-1]) 三个里面挑最大

输入:
A: [1,2,3,2,1]
B: [3,2,1,4,7]
输出: 3
解释: 
长度最长的公共子数组是 [3, 2, 1]。

```c
class Solution {
public:
    int findLength(vector<int>& A, vector<int>& B) {
        int n = A.size(), m = B.size();
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));
        int ans = 0;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= m; ++j) {
                dp[i][j] = A[i-1] == B[j-1] ? dp[i - 1][j - 1] + 1 : 0;
                ans = max(ans, dp[i][j]);
            }
        }
        return ans;
    }
};
------------
class Solution {
public:
    int findLength(vector<int>& A, vector<int>& B) {
        int n = A.size(), m = B.size();
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                dp[i+1][j+1] = A[i] == B[j] ? dp[i][j] + 1 : 0;
                ans = max(ans, dp[i+1][j+1]);
            }
        }
        return ans;
    }
};
```



## 二叉树C++

```c++
#include <iostream>
using namespace std;

typedef struct BinaryTree {
	BinaryTree *Lchild;
	BinaryTree *Rchild;
	int data;
}BinaryTree;
int Construct(BinaryTree **T) {
	int ch;
	cin >> ch;
	if (ch == -1) {
		*T = NULL;
		return 0;
	}
	else
	{
		*T = (BinaryTree *)malloc(sizeof(BinaryTree));
		if (T == NULL)
			cout << "malloc failed!" << endl;
		else
		{
			(*T)->data = ch;
			cout << "请输入" << ch << "的左子节点：" << endl;
			Construct(&((*T)->Lchild));
			Construct(&((*T)->Rchild));
		}
			

	}

}
int main(int argc, char **argv) {
	cout << "BinaryTree Construct Stage..." << endl;
	BinaryTree *Btree;
	cout << "请输入二叉树第一个节点的值，-1代表叶子节点..." << endl;
	Construct(&Btree);
	return 0;
}
```

BTree本来是一个指向BinaryTree的指针，

因为有小伙伴问了，可否在构建二叉树传入的参数为一级地址。上述的方法是一定要传二级参数的，但是这里给出一个传一级参数的方法，小伙伴也可以通过对比两种方法，对二叉树的构建和传参方式有更深的理解。

```c
struct TreeNode* Create(){
	int val;
	scanf("%d", &val);
	
	struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode*));
	if (val <= 0) {
		return NULL;
	}
	
	if (!root) {
		printf("创建失败\n");
	}
 
	if (val > 0) {
		root->val = val;
		root->left = Create();
		root->right = Create();
	}
	 
	return root;
}
```

## 手写：木头切割问题

今天继续补充一道Leetcode上找不到的高频题，木头切割问题。

> 此题经常在字节跳动后端面试中遇到，**尤其是教育部门的三面**。之后面试大概率还会考察这道题。

给定长度为n的数组，每个元素代表一个木头的长度，木头可以任意截断，从这堆木头中截出至少k个相同长度为m的木块。已知k，求max(m)。

输入两行，第一行n, k，第二行为数组序列。输出最大值。

> 输入
> 5 5
> 4 7 2 10 5
> 输出
> 4
> 解释：如图，最多可以把它分成5段长度为4的木头
>
> ![Image](https://mmbiz.qpic.cn/mmbiz_png/oD5ruyVxxVHVR60EJHyZEZAdt5KkTSSvpjP30ZWe9WxlFFHibiaPchmjVcVpkkCkVqUNicm9NReAvCbKC0vdy6sZg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

ps:数据保证有解，即结果至少是1。 

方法一：暴力。大概思路就是从1遍历到木棍最长的长度，每次遍历的长度作为m，如果可以将所有木头截出来k个长度为m的木块，则更新最大值，最后输出最大值即可。可以通过下面的伪代码片段辅助理解：

```c
// input n, k;
int maxV = max(a[0 ~ n - 1]);
int res = 0;
while (1 <= maxV)
{
    int cnt = 0;
    for (int i = 0; i < n; i ++ ) cnt += a[i] / m;
    if (cnt >= k) res = max(res, cnt);  // 如果当前可以截出来超过k段，就更新结果
    m ++;
}

cout << res << endl;
```

上面的代码也比较容易理解，这里就不多展开说了。时间复杂度也很容易看出来是O(n * len), len为木头中最大的长度。容易想到遍历长度时可以从大到小遍历，`if (cnt >= k)`成立，则该值即为最终结果，可直接break，但最坏时间复杂度没变。

方法二：二分。方法一在[1,max]寻找最大长度时是顺序遍历，由于其有序，我们可借助二分来快速检出结果。如果能截出来k个长度为x的木块，说明答案肯定 >= x，则接下来只需在[x,max]中找m最大满足条件的长度。反之则说明答案 < x，则在[1,x-1]中寻找结果。这样我们每次可以舍弃1/2的情况，因此使用二分的时间复杂度是O(n * log Len)。

```c
#include <iostream>
using namespace std;

const int N = 100010;
int a[N];
int n, k;

int check(int mid)
{
    int res = 0;
    for (int i = 0; i < n; i ++ ) res += a[i] / mid;
    return res;
}

int main()
{
    cin >> n >> k;
    int l = 1, r = -1;
    
    for (int i = 0; i < n; i ++ )
    {
        cin >> a[i];
        r = max(r, a[i]);
    }
    
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid) >= k) l = mid;
        else r = mid - 1;
    }
    
    cout << l << endl;
    return 0;
}
```

## 手写：IP 地址转整数

腾讯CSIG0720 面试题

```c
//以下代码输入输出格式是为满足牛客评测系统
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

unsigned ipToInt(string ip) {
    int l = ip.size();
    vector<int> ipList;
    //split
    for (int i = 0; i < l; i++) {
        int j = i;
        while (j < l && ip[j] != '.') j++;
        ipList.push_back(stoi(ip.substr(i, j - i)));
        i = j;
    }
    int n = ipList.size();
    unsigned res = 0;
    for (int i = 0; i < n; i++) {
        res = res << 8 | ipList[i];
    }
    return res;
}

string intToIp(unsigned num) {
    vector<string> ipList;
    string res = "";
    for(int i = 0; i < 4; i ++) {
        string seg = to_string(num & 255);
        ipList.push_back(seg);
        num = num >> 8;
    }
    reverse(ipList.begin(), ipList.end());
    for(int i = 0; i < 4; i ++) {
        if(i == 3) res += ipList[i];
        else res += ipList[i] + '.';
    }
    return res;
}
int main()
{
    string ip;
    unsigned num;
    while(cin >> ip) {
        cin >> num;
        cout << ipToInt(ip) << endl;
        cout << intToIp(num) << endl;
    }
}
```



## 手写：寻找重复的值

```c
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        int i = 0;
        while(i < nums.size()) {
            if(nums[i] == i) {
                i++;
                continue;
            }
            if(nums[nums[i]] == nums[i])
                return nums[i];
            swap(nums[i],nums[nums[i]]);
        }
        return -1;
    }
};
```



## 手写：螺旋矩阵

```c

class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        
        int u = 0;
        int d = matrix.size() - 1;
        int l = 0; 
        int r = matrix[0].size() - 1;
        vector<int> ans;
        if(matrix.empty()) return ans; //若数组为空，直接返回答案
        while(true){
            for(int j = l; j <= r; ++j) ans.push_back(matrix[u][j]);
            if(++u > d) break;
            for(int i = u; i <= d; ++i) ans.push_back(matrix[i][r]);
            if(--r < l) break;
            for(int j = r; j >= l; --j) ans.push_back(matrix[d][j]);
            if(--d < u) break;
            for(int i = d; i >= u; --i) ans.push_back(matrix[i][l]);
            if(++l > r) break;
        }
        return ans;
    }
};

```



## 手写：接雨水

```c
int trap(vector<int>& height)
{
    int left = 0, right = height.size() - 1;
    int ans = 0;
    int left_max = 0, right_max = 0;
    while (left < right) {
        if (height[left] < height[right]) {
            height[left] >= left_max ? (left_max = height[left]) : ans += (left_max - height[left]);
            ++left;
        }
        else {
            height[right] >= right_max ? (right_max = height[right]) : ans += (right_max - height[right]);
            --right;
        }
    }
    return ans;
}

作者：LeetCode
链接：https://leetcode-cn.com/problems/trapping-rain-water/solution/jie-yu-shui-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



## 手写： rand5实现rand3和rand8 

```c
//使用Rand5()实现Rand3()   
int Rand3()  
{  
    int x;  
    do  
    {  
        x = Rand5();  
    } while (x >= 3);  
    return x;  
}  
//利用Rand3编写Rand5怎么办？   
int Rand5()  
{  
    int x;  
    do  
    {  
        x = Rand3() * 3 + Rand3();  
    } while (x >= 5);  
    return x;  
}   
//如果要求利用Rand5编写Rand7怎么办？   
int Rand7()  
{  
    int x;  
    do  
    {  
        x = Rand5() * 5 + Rand5();  
    } while (x >= 21);  
    return x % 7;  
}   
// 这个是[1,10]范围的，所以需要减一
int rand_10()    
{    
    int x = 0;    
    do    
    {    
        x = 7 * (rand7() - 1) + rand7();    
    }while(x > 40);    
    return x % 10 + 1;    
}   
```

199周赛

房间中有 n 个灯泡，编号从 0 到 n-1 ，自左向右排成一行。最开始的时候，所有的灯泡都是 关 着的。

请你设法使得灯泡的开关状态和 target 描述的状态一致，其中 target[i] 等于 1 第 i 个灯泡是开着的，等于 0 意味着第 i 个灯是关着的。

有一个开关可以用于翻转灯泡的状态，翻转操作定义如下：

选择当前配置下的任意一个灯泡（下标为 i ）
翻转下标从 i 到 n-1 的每个灯泡
翻转时，如果灯泡的状态为 0 就变为 1，为 1 就变为 0 。

返回达成 target 描述的状态所需的 最少 翻转次数。

> 聪明人一眼就看出这是找规律，可惜我不是聪明人！这道题就是找相邻两个字符不相同的个数，开头如果有0的话需要把开头这些0去除掉。

```
输入：target = "10111"
输出：3
解释：初始配置 "00000".
从第 3 个灯泡（下标为 2）开始翻转 "00000" -> "00111"
从第 1 个灯泡（下标为 0）开始翻转 "00111" -> "11000"
从第 2 个灯泡（下标为 1）开始翻转 "11000" -> "10111"
至少需要翻转 3 次才能达成 target 描述的状态

 
输入：target = "001011101"
输出：5
```

```c
class Solution {
public:
    int minFlips(string target) {
        int count = 1;
        int i = 0;
        while(i < target.size() && target[i] == '0'){
            i++;
        }
        if(i == target.size()) return 0;
        for(; i < target.size() - 1; ++i){
            if(target[i] != target[i+1] ){
                count++;
            }
        }
        return count;
    }
};
```

来看看大佬的做法：

```c
class Solution {
public:
    int minFlips(string target) {
        int cur = 0, ans = 0;
        for(char c : target) {
            int d = c - '0';
            if((d ^ cur) == 1) {//异或就是异性能得1，能生孩子
                cur ^= 1;//相当于做一个反转
                ans++;
            }
        }
        return ans;
    }
};
```

## 求一个字符串中连续出现次数最多的子串

例如字符串“abababc”,最多连续出现的为ab，连续出现三次。要和求一个字符串中的最长重复子串区分开来，还是上面的字符串，那么最长的重复子串为abab。两个题目的解法有些类似，都用到了后缀数组这个数据结构。求一个字符串中连续出现的次数最多的子串，首先生成后缀数组例如上面的字符串为:

```c
abababc
bababc
ababc
babc
abc
bc
c
```

可以看出第一个后缀数组和第三个后缀数组的起始都为ab，第5个后缀数组也为ab。可以看出规律来，一个字符串s，如果第一次出现在后缀数组i的前面，那么如果它重复出现，下一次出现应该在第i+len(s)个后缀数组的前面。

```c
#include <iostream>
#include <cstring>
#include <utility>
#include <string>
#include <vector>
using namespace std;

pair<int, string> fun(const string& str)
{
    vector<string> subs;
    int len = str.size();
    for (int i = 0; i < len; i++)
    {
        subs.push_back(str.substr(i));
    }

    int count = 1;
    int maxCount = 1;
    string sub;

    for (int i = 0; i < len; i++)
    {
        for (int j = i + 1; j < len; j++)
        {
            count = 1;
            if (subs[i].substr(0, j - i) == subs[j].substr(0, j - i))
            {
                ++count;
                //j-i为子串长度
                for (int k = j + j - i; k < len; k += j - i)
                {
                    if (subs[i].substr(0, j - i) == subs[k].substr(0, j - i))
                    {
                        ++count;
                    }
                    else
                    {
                        break;
                    }
                }
                if (count > maxCount)
                {
                    maxCount = count;
                    sub = subs[i].substr(0, j - i);
                }
            }
        }
    }

    return make_pair(maxCount, sub);
}

int main()
{
    string str;
    pair<int, string> rs;
    while (cin>>str)
    {
        rs = fun(str);
        cout<<rs.second<<":"<<rs.first<<endl;
    }

    return 0;
}
```

## 手写：用栈实现队列

```c
class MyQueue {
public:
    /** Initialize your data structure here. */
    MyQueue() {

    }
    
    /** Push element x to the back of queue. */
    void push(int x) {
        A.push(x);
    }
    
    /** Removes the element from in front of queue and returns that element. */
    int pop() {
        if (B.empty()) {
            while (!A.empty()) {
                B.push(A.top());
                A.pop();
            }
        }
        int ret = B.top();
        B.pop();
        return ret;
    }
    
    /** Get the front element. */
    int peek() {
        int ans = this->pop();
        B.push(ans);
        return ans;
    }
    
    /** Returns whether the queue is empty. */
    bool empty() {
        return A.empty() && B.empty();
    }
private:
    stack<int> A;
    stack<int> B;    
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->peek();
 * bool param_4 = obj->empty();
 */
```





## 手写：岛屿数量

```c
class Solution {
private:
    void dfs(vector<vector<char>>& grid, int r, int c) {
        int nr = grid.size();
        int nc = grid[0].size();

        grid[r][c] = '0';
        if (r - 1 >= 0 && grid[r-1][c] == '1') dfs(grid, r - 1, c);
        if (r + 1 < nr && grid[r+1][c] == '1') dfs(grid, r + 1, c);
        if (c - 1 >= 0 && grid[r][c-1] == '1') dfs(grid, r, c - 1);
        if (c + 1 < nc && grid[r][c+1] == '1') dfs(grid, r, c + 1);
    }

public:
    int numIslands(vector<vector<char>>& grid) {
        int nr = grid.size();
        if (!nr) return 0;
        int nc = grid[0].size();

        int num_islands = 0;
        for (int r = 0; r < nr; ++r) {
            for (int c = 0; c < nc; ++c) {
                if (grid[r][c] == '1') {
                    ++num_islands;
                    dfs(grid, r, c);
                }
            }
        }

        return num_islands;
    }
};

作者：LeetCode
链接：https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-shu-liang-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



## 手写：实现strStr、KMP

实现字符串匹配算法

```c
class Solution {
public:
    int strStr(string haystack, string needle) {
        if(needle.empty())
            return 0;
        
        int i=0,j=0;
        while(haystack[i]!='\0'&&needle[j]!='\0')
        {
            if(haystack[i]==needle[j])
            {
                i++;
                j++;
            }
            else
            {
                i=i-j+1; // i 比 j 长，且移动了 j 个单位，回退到之前的下一个位置需要加一
                j=0;
            }
        }
        if(needle[j]=='\0')
            return i-j;
        
        return -1;
    }
};

作者：Nanase_
链接：https://leetcode-cn.com/problems/implement-strstr/solution/c5chong-jie-fa-ku-han-shu-bfkmpbmsunday-by-2227/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



## 手写：最小栈

官方题解：

![fig1](https://assets.leetcode-cn.com/solution-static/155/155_fig1.gif)

```c
class MinStack {
    stack<int> x_stack;
    stack<int> min_stack;
public:
    MinStack() {
        min_stack.push(INT_MAX);
    }
    
    void push(int x) {
        x_stack.push(x);
        min_stack.push(min(min_stack.top(), x));
    }
    
    void pop() {
        x_stack.pop();
        min_stack.pop();
    }
    
    int top() {
        return x_stack.top();
    }
    
    int getMin() {
        return min_stack.top();
    }
};

```

**注意和窗口最小值和最小队列区分开来，那两个需要无限弹出**

如果说只用一个栈的话可以:

```c
class MinStack {
public:
    /** initialize your data structure here. */
    MinStack() {
    }
    
    void push(int x) {
        if (st.size() == 0) {
            st.push({x, x});
        } else {
            st.push({x, min(x, st.top().second)});
        }
    }
    
    void pop() {
        st.pop();
    }
    
    int top() {
        return st.top().first;
    }
    
    int getMin() {
        return st.top().second;
    }
private:
    stack<pair<int, int>> st;
};
```

## 手写：三数之和

注意去重处理：不光第一个元素需要去重，第二个元素也需要去重

```c
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        if (nums.size() < 3) return {};
        sort(nums.begin(), nums.end());
        vector<vector<int>> res;
        for (int i = 0; i < nums.size() - 2; ++i) {
            if (nums[i] > 0) continue;
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }       
            int right = nums.size() - 1;
            for (int left = i + 1; left < right; ++left) {
                if (left > i + 1 && nums[left] == nums[left - 1]) {
                    continue;
                }
                while (left < right && nums[left] + nums[right] > -nums[i]) {
                    --right;
                }
                if (left == right) break;
                if (nums[left] + nums[right] == -nums[i]) {
                    res.push_back({nums[i], nums[left], nums[right]});
                }
            }     

        }
        return res;
    }
};
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) 
    {
        int size = nums.size();
        if (size < 3)   return {};          // 特判
        vector<vector<int> >res;            // 保存结果（所有不重复的三元组）
        std::sort(nums.begin(), nums.end());// 排序（默认递增）
        for (int i = 0; i < size; i++)      // 固定第一个数，转化为求两数之和
        {
            if (nums[i] > 0)    return res; // 第一个数大于 0，后面都是递增正数，不可能相加为零了
            // 去重：如果此数已经选取过，跳过
            if (i > 0 && nums[i] == nums[i-1])  continue;
            // 双指针在nums[i]后面的区间中寻找和为0-nums[i]的另外两个数
            int left = i + 1;
            int right = size - 1;
            while (left < right)
            {
                if (nums[left] + nums[right] > -nums[i])
                    right--;    // 两数之和太大，右指针左移
                else if (nums[left] + nums[right] < -nums[i])
                    left++;     // 两数之和太小，左指针右移
                else
                {
                    // 找到一个和为零的三元组，添加到结果中，左右指针内缩，继续寻找
                    res.push_back(vector<int>{nums[i], nums[left], nums[right]});
                    left++;
                    right--;
                    // 去重：第二个数和第三个数也不重复选取
                    // 例如：[-4,1,1,1,2,3,3,3], i=0, left=1, right=5
                    while (left < right && nums[left] == nums[left-1])  left++;
                    while (left < right && nums[right] == nums[right+1])    right--;
                }
            }
        }
        return res;
    }
};
```



## 手写：线程安全单例模式

 在c++设计模式中提出一种很简单的实现方法：其实现过程是这样的，首先要保证一个类只有一个实例，而且使用类静态指针指向唯一的实例；当然就在类中构造一个实例，那么就要调用构造函数，为了防止在类的外部调用类的构造函数创建实例，需要将构造函数访问权限设计成私有的；当然要提供一个全局的访问节点，那么就类中定义一个static函数，在其函数体中调用类的构造函数创建实例并且返回这个唯一的构造实例。说了这么多，还不如上代码仔细品味这段话的意思，代码:

 我们从头到尾都没考虑线程安全问题，如果你使用第四种方法，恭喜你无意识中避免了线程安全，这又另外一个话题了：在c++ 11新标准中，静态局部变量是线程安全的参考文章：http://anotherlayer.net/2012/05/04/static-initialization-and-thread-safety/
```c
#include <iostream>
using namespace std;
 
class Singleton
{
public:
	static Singleton* get_instance()
	{
		static Singleton instance;
		return &instance;
	}
 
private:
	Singleton(){}; //构造函数设计成私有的
 
	Singleton(const Singleton&);
 
	Singleton& operator==(const Singleton&);
 
};
 
int main(int argc, char*argv[])
{
	Singleton *object = Singleton::get_instance();
 
	return 0;
}

class singleton {
private:
    singleton() {}
    static singleton *p;
public:
    static singleton *instance();
};

singleton *singleton::p = new singleton();
singleton* singleton::instance() {
    return p;
}
```

## 手写：智能指针

// this 是对象的地址，that 是一个引用，会被自动解引用为 * that,所以为了获取对象地址，需要使用&取地址

if (this != &that)

或者还可以写成 if (*this == that)

```c
#pragma once

template<class T>
class SharedPointer
{
public:
	//默认构造函数，内部指针，未指向任何资源，引用计数为0,因为它未与任何资源绑定
	SharedPointer() :m_refCount(nullptr), m_pointer(nullptr) {}

	//构造函数，初始化时，指向一个已经分配好的资源
	SharedPointer(T* adoptTarget) :m_refCount(nullptr), m_pointer(adoptTarget)
	{
		addReference();
	}

	//构造函数，使用其它对象创建新对象
	SharedPointer(const SharedPointer<T>& copy)
		:m_refCount(copy.m_refCount), m_pointer(copy.m_pointer)
	{
		addReference();
	}

	//析构函数，引用计数递减，当为0时，释放资源
	virtual ~SharedPointer()
	{
		removeReference();
	}

	//赋值操作
	//当左值被赋值时，表明它不再指向所指的资源，故引用计数减一
	//之后，它指向了新的资源，所以对应这个资源的引用计数加一
	SharedPointer<T>& operator=(const SharedPointer<T>& that)
	{
        // this 是对象的地址，that 是一个引用，会被自动解引用为 * that,所以为了获取对象地址，需要使用&取地址
		if (this != &that)
		{
			removeReference();
			this->m_pointer = that.m_pointer;
			this->m_refCount = that.m_refCount;
			addReference();
		}
		return *this;
	}

	//判断是否指向同一个资源
	bool operator==(const SharedPointer<T>& other)
	{
		return m_pointer == other.m_pointer;
	}
	bool operator!=(const SharedPointer<T>& other)
	{
		return !operator==(other);
	}

	//指针解引用
	T& operator*() const
	{
		return *m_pointer;
	}
	//调用所知对象的公共成员
	T* operator->() const
	{
		return m_pointer;
	}

	//获取引用计数个数
	int GetReferenceCount() const
	{
		if (m_refCount)
		{
			return *m_refCount;
		}
		else
		{
			return -1;
		}
	}

protected:
	//当为nullpter时，创建引用计数资源，并初始化为1
	//否则，引用计数加1。
	void addReference()
	{
		if (m_refCount)
		{
			(*m_refCount)++;
		}
		else
		{
			m_refCount = new int(0);
			*m_refCount = 1;
		}
	}

	//引用计数减一，当变为0时，释放所有资源
	void removeReference()
	{
		if (m_refCount)
		{
			(*m_refCount)--;
			if (*m_refCount == 0)
			{
				delete m_refCount;
				delete m_pointer;
				m_refCount = 0;
				m_pointer = 0;
			}
		}
	}

private:
	int* m_refCount;
	T* m_pointer;
};

```



举个例子，遍历经过 IVIV 的时候先记录 II 的对应值 11 再往前移动一步记录 IVIV 的值 33，加起来正好是 IVIV 的真实值 44。max 函数在这里是为了防止遍历第一个字符的时候出现 [-1:0]的情况

```c
class Solution {
public:
    int romanToInt(string s) {
        unordered_map<string, int> m = {{"I", 1}, {"IV", 3}, {"IX", 8}, {"V", 5}, {"X", 10}, {"XL", 30}, {"XC", 80}, {"L", 50}, {"C", 100}, {"CD", 300}, {"CM", 800}, {"D", 500}, {"M", 1000}};
        int r = m[s.substr(0, 1)];
        for(int i=1; i<s.size(); ++i){
            string two = s.substr(i-1, 2);
            string one = s.substr(i, 1);
            r += m[two] ? m[two] : m[one];
        }
        return r;
    }
};
```





## 手写：strcpy()

```c
#include<iostream>
using namespace std;

char* strcpy(char *strSrc, char *strDest)
{
	if ((strSrc == NULL) || (strDest == NULL))
		return NULL;
	char *strDestCopy = strDest;
	while ((*strDest++ = *strSrc++) != '\0');
		return strDestCopy;
}


int main()
{
	char strSrc[] = "Hello World!";
	char strDest[20];
	strcpy(strSrc, strDest);
	cout << "strDest: " << strDest << endl;
	return 0;
}
```



## 手写：统计数组中不同元素出现的次数

（时间复杂度O(n)，空间复杂度O(1))

```c
vector findNumbers(vector& nums) {
        int n = nums.size();
        for (int i = 0; i < n; ++ i )
        {
            while (nums[i] > 0)
            {
                int cur;
                if (nums[nums[i]-1] > 0) 
                {
                    cur = nums[i]-1;
                    nums[i] = nums[nums[i]-1];
                    nums[cur] = -1;
                }
                else if (nums[nums[i]-1] != inf)
                {
                    cur = nums[i]-1;
                    nums[i] = inf;
                    nums[cur] -= 1;
                }
                else
                {
                    cur = nums[i]-1;
                    nums[i] = inf;
                    nums[cur] = -1;
                }
            }
        }
        vector ans;
        for (int i = 0; i < n; ++ i ) 
            if (nums[i] == inf) ans.push_back(0);
            else ans.push_back(-nums[i]);
        return ans;
    }
-------------------------------
#include <iostream> 
#include <algorithm> 
#include <vector> 
#include <queue>
#include <stack>
#include <string> 
#include <string.h> 
#include <fstream> 
#include <map> 
#include <iomanip> 
#include <cstdio> 
#include <cstdlib>
#include <cmath>
#include <deque>
#include <hash_map>
 
using namespace std; 
 
const int MAX = 0x7FFFFFFF; 
const int MIN = 0x80000000; 
 
void work(int a[], int n)
{
	int i = 0;
	while(i < n)
	{
		int temp = a[i] - 1;
		if(temp < 0)
		{
			i++;
			continue;
		}
		if(a[temp] > 0)
		{
			a[i] = a[temp];
			a[temp] = -1;
		}
		else
		{
			a[temp]--;
			a[i] = 0;
		}
	}
}
 
int main()
{
	int n;
	while(cin >> n)
	{
		int *a = new int[n];
		for(int i = 0; i < n; i++)
			cin >> a[i];
		work(a, n);
		for(int i = 0; i < n; i++)
			if(a[i] < 0)
				cout << i + 1 << " " << (-a[i]) << endl;
		cout << "********************" << endl;
		delete[] a;
	}
	system("pause");
	return 0;
}
```

## 手写：统计一个数字在排序数组中出现次数

统计一个数字在排序数组中出现的次数。

 示例 1:

输入: nums = [5,7,7,8,8,10], target = 8
输出: 2
示例 2:

输入: nums = [5,7,7,8,8,10], target = 6
输出: 0

```c
class Solution {
    public int search(int[] nums, int target) {
        // 搜索右边界 right
        int i = 0, j = nums.length - 1;
        while(i <= j) {
            int m = (i + j) / 2;
            if(nums[m] <= target) i = m + 1;
            else j = m - 1;
        }
        int right = i;
        // 若数组中无 target ，则提前返回
        if(j >= 0 && nums[j] != target) return 0;
        // 搜索左边界 right
        i = 0; j = nums.length - 1;
        while(i <= j) {
            int m = (i + j) / 2;
            if(nums[m] < target) i = m + 1;
            else j = m - 1;
        }
        int left = j;
        return right - left - 1;
    }
}

作者：jyd
链接：https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/solution/mian-shi-ti-53-i-zai-pai-xu-shu-zu-zhong-cha-zha-5/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



## 牛客：字符串压缩

```c
#include <iostream>
using namespace std;
int main(int argc, char** argv) {
    string s;
    cin >> s;
    int i = 0;
    while (i < strlen(s)) {
        if (s[i] == ']') {
            int j = i; // j 用来向前寻找 [
            int k = i; // k 用来向前寻找 |
            while (s[j] != '[') {
                if (s[j] == '|') {
                    k = j;
                }
                --j;
            }
            int len = stoi(s.substr(j + 1, k - j - 1));
            string s1 = s.substr(k + 1, i - k - 1); // s1 存储 | 之后的字符串
            string s2;
            for (int p = 0; p < len; ++p) {
                s2 += s1;
            }
            s.replace(j, i - j + 1, s2);
            i = j;
        }
        ++i;
    }
    cout << s;
}
```



## 手写：正则表达式

题目：glob是一种Unix风格的路径匹配模式，其规则如下：
        1.字符/作为分隔符存在
        2.字符\*匹配除/之外的任意长度的任意字符
        3.字符？匹配除/之外的单个长度的任意字符
        4.中括号[]用来转移‘\*’、‘？’、‘['、’]‘这四个特殊字符，一次转义一个字符
        5.其他字符保持原有含义
        6.对’.‘号开头的文件夹或者文件名，规则1，2不生效
输入1：“pattern. \*”,"pattern.txt"
输出1：true

输入2：“dir/\*”,"dir/.env"
输出2：false

```c
```



## 手写：二分法

**二分法第一种写法**

以这道题目来举例，以下的代码中定义 target 是在一个在左闭右闭的区间里，**「也就是[left, right] （这个很重要）」**。

这就决定了这个二分法的代码如何去写，大家看如下代码：

**「大家要仔细看注释，思考为什么要写while(left <= right)， 为什么要写right = middle - 1」**。

```c
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int n = nums.size();
        int left = 0;
        int right = n - 1; // 定义target在左闭右闭的区间里，[left, right] 
        while (left <= right) { // 当left==right，区间[left, right]依然有效
            int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2
            if (nums[middle] > target) {
                right = middle - 1; // target 在左区间，所以[left, middle - 1]
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，所以[middle + 1, right]
            } else { // nums[middle] == target
                return middle;
            }
        }
        // 分别处理如下四种情况
        // 目标值在数组所有元素之前  [0, -1]
        // 目标值等于数组中某一个元素  return middle;
        // 目标值插入数组中的位置 [left, right]，return  right + 1
        // 目标值在数组所有元素之后的情况 [left, right]， return right + 1
        return right + 1;
    }
};
```

**二分法第一种写法**

如果说定义 target 是在一个在左闭右开的区间里，也就是[left, right) 。

那么二分法的边界处理方式则截然不同。

不变量是[left, right)的区间，如下代码可以看出是如何在循环中坚持不变量的。

**「大家要仔细看注释，思考为什么要写while (left < right)， 为什么要写right = middle」**。

```c
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int n = nums.size();
        int left = 0;
        int right = n; // 定义target在左闭右开的区间里，[left, right)  target
        while (left < right) { // 因为left == right的时候，在[left, right)是无效的空间
            int middle = left + ((right - left) >> 1);
            if (nums[middle] > target) {
                right = middle; // target 在左区间，在[left, middle)中
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，在 [middle+1, right)中
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值的情况，直接返回下标
            }
        }
        // 分别处理如下四种情况
        // 目标值在数组所有元素之前 [0,0)
        // 目标值等于数组中某一个元素 return middle
        // 目标值插入数组中的位置 [left, right) ，return right 即可
        // 目标值在数组所有元素之后的情况 [left, right)，return right 即可
        return right;
    }
};
```

## 手写：X 的平方

由于 xx 平方根的整数部分 \textit{ans}ans 是满足 k^2 \leq xk 
2
 ≤x 的最大 kk 值，因此我们可以对 kk 进行二分查找，从而得到答案。

二分查找的下界为 00，上界可以粗略地设定为 xx。在二分查找的每一步中，我们只需要比较中间元素 \textit{mid}mid 的平方与 xx 的大小关系，并通过比较的结果调整上下界的范围。由于我们所有的运算都是整数运算，不会存在误差，因此在得到最终的答案 \textit{ans}ans 后，也就不需要再去尝试 \textit{ans} + 1ans+1 了。

```c
class Solution {
public:
    int mySqrt(int x) {
        int l = 0, r = x, ans = -1;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if ((long long)mid * mid <= x) {
                ans = mid;
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        return ans;
    }
};

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/sqrtx/solution/x-de-ping-fang-gen-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



## 手写：旋转图像

给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。

 ![image-20210721231510439](https://i.loli.net/2021/07/21/hImSYByt5XAgCzR.png)

![image-20210721232007758](https://i.loli.net/2021/07/21/M3kHLWwV6scrf8S.png)

```c
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        // 水平翻转
        for (int i = 0; i < n / 2; ++i) {
            for (int j = 0; j < n; ++j) {
                swap(matrix[i][j], matrix[n - i - 1][j]);
            }
        }
        // 主对角线翻转
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < i; ++j) {
                swap(matrix[i][j], matrix[j][i]);
            }
        }
    }
};

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/rotate-image/solution/xuan-zhuan-tu-xiang-by-leetcode-solution-vu3m/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```









0303

查找旋转排序数组的最小值

注意看当 numbers[pivot] < numbers[high] 时是不减一的哈，因为 pivot 此时可能正在最小值处

```c
        int low = 0;
        int high = numbers.size() - 1;
        while (low <= high) {
            int pivot = low + (high - low) / 2;
            if (numbers[pivot] < numbers[high]) {
                high = pivot;
            }
            else if (numbers[pivot] > numbers[high]) {
                low = pivot + 1;
            }
            else {
                high -= 1;
            }
        }
        return numbers[low];

图片链接：https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/solution/xun-zhao-xuan-zhuan-pai-xu-shu-zu-zhong-de-zui--16/
```



旋转数组的查找特定数字

下面的这个nums[0] <= target 处为何加个 = ？

因为当 nums[0] == target 时，应该让远处的 right 滚回来。而不是让就在此处的 left 再移动了

```c
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n = (int)nums.size();
        if (!n) {
            return -1;
        }
        if (n == 1) {
            return nums[0] == target ? 0 : -1;
        }
        int l = 0, r = n - 1;
        while (l <= r) {
            int mid = (l + r) / 2;
            if (nums[mid] == target) return mid;
            if (nums[0] <= nums[mid]) {
                if (nums[0] <= target && target < nums[mid]) {
                    r = mid - 1;
                } else {
                    l = mid + 1;
                }
            } else {
                if (nums[mid] < target && target <= nums[n - 1]) {
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            }
        }
        return -1;
    }
};

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/search-in-rotated-sorted-array/solution/sou-suo-xuan-zhuan-pai-xu-shu-zu-by-leetcode-solut/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```







## if else

```c
#include <iostream>
 
int main() {
    // 带 else 子句的简单 if 语句
    int i = 5;
    if (i < 2) {
        std::cout << i << " < 2\n";
    } else if(i > 3)
    
    {
        std::cout << i << " > 3\n";
    }
    else if(i > 4){
        std::cout << i << " > 4\n";
    }
}
---------
    5 > 3
--------
//它不执行下面那个 5 > 4 了！！！
```

```c
if (条件1)
{
    //语句1
}

if (条件2)
{
    //语句2
}
```



这种格式中，程序会依次判断条件1和条件2是否成立并根据结果决定是否执行语句1和语句2，也就是说，第一个 if 块和第二个 if 块没有影响（除非在执行第一个 if 块的时候就凶残地 return 了）

而下面这种格式，

```c
if (条件1) 
{
    //语句1
}
else if (条件2)
{
    //语句2
}
```

if 块和 else if 块本质上是互斥的！也就是说，一旦语句1得到了执行，程序会跳过 else if 块，else if 块中的判断语句以及语句2一定会被跳过；同时语句2的执行也暗含了条件1判断失败和语句1没有执行；当然还有第3个情况，就是条件1和条件2都判断失败，语句1和语句2都没有得到执行。



## 红黑树

>1、根节点是黑色；（头头是黑社会）
>
>2、叶子节点（NIL）也是黑色；（小弟也是黑社会）
>
>3、每个红色节点的两个子节点是黑色；（红社会下罩着两个黑社会）
>
>4、从任一节点到其每个叶子的所有路径包含相同数目的黑色节点；（黑社会要均衡，这保证了从根到叶子的最长路径不会超过最短路径的2倍）

![img](https://i.loli.net/2020/08/18/kfHviVJMUtbo34m.jpg)





### 0604

今天和7楼另外一个去阿里的学长交流了一下，他拿了阿里腾讯的sp，华为的ssp

> 1、Linux多线程编程 muduo库 10元（已出）
> 2、Unix环境高级编程 10元（已出）
> 3、Unnix网络编程 卷一+卷二 两本一共15元
> 4、C++ Primer 15元（已出）
> 5、Tcp/Ip详解 + Tcp/Ip网际互联 两本一共12元（已出）
>
> 这几本书研一研二就应该看完
>
> 程序员自我修养 Effective C++ + more effective C++ 两本 这几本书应该在找工作前看三遍以上，剑指offer 也是，面试时这些C++ 的基础并不会问的很深，但是这几本书会问的很深

## 美团0313笔试

滑动窗口找最小

```c
#include<iostream>
#include<string>
#include<vector>
#include<algorithm>
#include<unordered_map>
using namespace std;
#define LOCAL
#pragma warning (disable: 4996)
bool comp(pair<int, int> a, pair<int, int> b) {
	return a.second < b.second;
}
int main()
{
	int num, cnt;
#ifdef LOCAL
	freopen("out.txt", "r", stdin);
	//freopen("out.txt", "w", stdout);
#endif
	while (cin >> num >> cnt) {
		vector<int> arr(num);
		for (int i = 0; i < num; ++i) {
			cin >> arr[i];
		}
		for (int i = 0; i < num - cnt + 1; ++i) {
			unordered_map<int, int> hash_;
			vector<pair<int, int>> vec;
			for (int j = 0; j < cnt; ++j) {
				hash_[arr[i + j]]++;
			}
			for (auto& i : hash_) {
				vec.push_back(i);
			}
			std::sort(vec.begin(), vec.end(), [](pair<int, int>& A, pair<int, int>& B) {return A.second > B.second; });
			// for (auto& i : vec) cout << i.first << " :" << i.second << endl;
			if (vec[0].second == 1) {
				std::sort(vec.begin(), vec.end(), [](pair<int, int>& A, pair<int, int>& B) {return A.first < B.first; });
				cout << vec[0].first << endl;
			}
			else 
				cout << vec[0].first << endl;
		}
	}
	return 0;
}

```

还有一种堆的算法：

    //对于基础类型 默认是大顶堆
    priority_queue<int> a; 
    //等同于 priority_queue<int, vector<int>, less<int> > a;
    
    //             这里一定要有空格，不然成了右移运算符↓
    priority_queue<int, vector<int>, greater<int> > c;  //这样就是小顶堆
```c
#include <iostream>
#include <queue>
#include <vector>
using namespace std;
int main() 
{
    priority_queue<pair<int, int> > a;
    pair<int, int> b(1, 2);
    pair<int, int> c(1, 3);
    pair<int, int> d(2, 5);
    a.push(d);
    a.push(c);
    a.push(b);
    while (!a.empty()) 
    {
        cout << a.top().first << ' ' << a.top().second << '\n';
        a.pop();
    }
}
```

