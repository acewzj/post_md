---
title:  "Schedule"
date:   2020-03-17 10:16:18 +0800
categories:
- CPP
tags:
- ML 




---


- 2020秋招提前批
- C/C++相关开发
- 拿到**腾讯**、华为等offer

------

<!--more-->

## 阿里

语言
什么是指针
什么是野指针和悬空指针
指针和引用的区别

传值和传指针的区别

C++ 11 新特性
inline 实现原理
知道哪些设计模式
C++ 类的初始化顺序
怎么实现 malloc 和 free 方法
define 和 const 的区别
构造函数可以申明为 virtual 的形式吗，如果声明会发生什么
深拷贝和浅拷贝
计算机网络
tcp 三次握手和四次挥手

### tcp 实现可靠传输的机制

>1. 应用数据被分割成 TCP 认为最适合发送的数据块。
>2. TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。
>3. **校验和：**TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。
>4. TCP 的接收端会丢弃重复的数据。
>5. **流量控制：**TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）
>6. **拥塞控制：**当网络拥塞时，减少数据的发送。
>7. **ARQ协议：**也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。
>8. **超时重传：**当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

ip 协议的作用
socket() 套接字有哪些

>套接字有3种类型：流式套接字（SOCK_STREAM）、数据包套接字（SOCK_DGRAM）和原始套接字。流式套接字可以提供可靠的、面向连接的通信流。如果通过流式套接字发送了顺序的数据：1、2。那么数据到达远程时候的顺序也是1、2。流式套接字可用于Telnet远程连接、WWW服务等需要使数据顺序传递的应用，它使用TCP协议保证数据传输的可靠性。流式套接字的工作原理如图18.9所示，我们将网络中的两台主机分别作为服务器和客户机看待。
>
>数据包套接字定义了一种无连接的服务，数据通过相互独立的报文进行传输，是无序的，并且不保证可靠性。数据包套接字使用者数据包协议UDP，数据只是简单地传送到对方。数据包套接字的工作原理如图18.10所示。
>
>原始套接字允许对低层协议如IP或ICMP直接访问，主要用于新的网络协议实现的测试等。原始套接字主要用于一些协议的开发，可以进行比较底层的操作。它功能强大，但是没有上面介绍的两种套接字使用方便，一般的程序也涉及不到原始套接字。

http 和 https 的区别
select，poll，epoll的区别
tcp 和 udp 的区别
拥塞控制的算法
拥塞控制和流量控制的区别
高并发服务器客户端主动关闭连接和服务端主动关闭连接的区别
HTTP1.X 和 HTTP2.X 的区别
HTTP3 了解吗
数据结构
堆和栈有什么区别
vector 的扩容原理
resize() 和 reserve() 的区别

> std::vector的reserve和resize的区别
> \1. reserve: 分配空间，更改capacity但不改变size
> \2. resize: 分配空间，更改capacity也改变size

map 的底层是怎么实现的
map 和 unordered_map的区别
unordered_map 支持并发读取吗，如果要实现一个支持并发读取的 unordered_map 得话要怎么实现
解决哈希冲突 的方法有哪些
什么是智能指针
什么是跳表
遍历二叉树的方式
map 容器如果 key 是类对象，对类有什么要求
vector 和 list 的区别
数据库
什么是索引

> 索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用*索引*，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录

Mysql 的 B+ 树是什么样的一个索引
B+ 树和 B 树有什么性能上的区别
数据库的并发安全是怎么做到的
事务的属性
事务的原子性怎么保证的

> 为了实现*原子性*，需要通过日志：
>
> redo:redo log是指在回放日志的时候把已经COMMIT的事务重做一遍，对于没有commit的事务按照abort处理，不进行任何操作。
>
> undo:undo log是把所有没有COMMIT的事务回滚到事务开始前的状态，系统崩溃时，可能有些事务还没有COMMIT，在系统恢复时，这些没有COMMIT的事务就需要借助undo log来进行回滚。

事务的提交过程
事务的隔离性怎么做到的
MVCC 是什么
数据库的隔离级别

> 1、数据库事务的属性－ACID（四个英文单词的首写字母）：
>
> 1）原子性（Atomicity）
>
> 所谓原子性就是将一组操作作为一个操作单元，是原子操作，即要么全部执行，要么全部不执行。
>
> 2）一致性（Consistency）
>
> 事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态。如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态。
>
> 3）隔离性（Isolation）
>
> 隔离性指并发的事务是相互隔离的。即一个事务内部的操作及正在操作的数据必须封锁起来，不被其它企图进行修改的事务看到。
>
> 4）持久性（Durability）
>
> 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。即一旦一个事务提交，DBMS（Database Management System）保证它对数据库中数据的改变应该是永久性的，持久性通过数据库备份和恢复来保证。
>
>  
>
> 2、在关系型数据库中，事务的隔离性分为四个隔离级别，在解读这四个级别前先介绍几个关于读数据的概念。
>
> 1）脏读（Dirty Reads）：所谓脏读就是对脏数据（Drity Data）的读取，而脏数据所指的就是未提交的数据。也就是说，一个事务正在对一条记录做修改，在这个事务完成并提交之前，这条数据是处于待定状态的（可能提交也可能回滚），这时，第二个事务来读取这条没有提交的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被称为脏读。
>
> 2）不可重复读（Non-Repeatable Reads）：一个事务先后读取同一条记录，但两次读取的数据不同，我们称之为不可重复读。也就是说，这个事务在两次读取之间该数据被其它事务所修改。
>
> 3）幻读（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为幻读。
>
>  
>
> 3、事务四个隔离级别对比：
>
> 1）未提交读（Read Uncommitted）：SELECT语句以非锁定方式被执行，所以有可能读到脏数据，隔离级别最低。
>
> 2）提交读（Read Committed）：只能读取到已经提交的数据。即解决了脏读，但未解决不可重复读。
>
> 3）可重复读（Repeated Read）：在同一个事务内的查询都是事务开始时刻一致的，InnoDB的默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻读。
>
> 4）串行读（Serializable）：完全的串行化读，所有SELECT语句都被隐式的转换成SELECT ... LOCK IN SHARE MODE，即读取使用表级共享锁，读写相互都会阻塞。隔离级别最高。

什么是幻读
R级别 会不会有幻读
mysql 的查询过程
操作系统
多线程什么时候需要同步
什么是缺页异常，什么情况下会缺页异常
进程间的通信机制
什么是共享内存
什么是线程安全，实现线程安全的机制
内核态线程的原理
什么是同步和异步
cpu的流水线机制
缓存一致性协议
程序通过一个地址读取一个变量的过程
一个进程的地址空间分为几段
可执行文件的文件格式
编译和链接的过程
互斥锁和信号量的区别
自旋锁和乐观锁
怎么在用户空间实现一个定时器
进程优先级和cpu任务调度策略
死锁发生的必要条件
什么是内存泄漏，如何定位内存泄漏
除了 RAII 机制还有什么方法可以避免内存泄漏
多线程下载比单线程快的原因
什么是分布式
内存池的作用
用户态和内核态的理解
硬中断和软中断
算法
堆排序的实现原理
二叉树中所有距离为k的节点
前k个高频元素
前k个高频单词
n个有序小文件，合并成有序的一个文件
用数组实现队列
实现快速排序
最长公共子序列
实现一个strcpy函数，考虑内存覆盖（源串可以被修改，保证复制的目的子串正确），实现多个字节同时拷贝（4字节或者8字节）
环形链表 II
归并排序的实现原理
合并k个升序链表
完全二叉树的节点个数
访问所有节点的最短路径

作者：陈乐乐
链接：https://leetcode-cn.com/circle/discuss/GZPHPo/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

### 阿里块存储实习2021-02-19

着重问项目

mysql 如何创建索引？

> 

编译链接流程

装饰器 python

struct 内存对齐怎么一回事

> 从理论上来讲，我们可以从任一字节位置处开始读取，但是实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是某个数k（通常它为4或8）的倍数，这就是所谓的内存对齐。
>
> 尽管内存是以字节为单位，但是大部分处理器并不是按字节块来存取内存的.它一般会以双字节,四字节,8字节,16字节甚至32字节为单位来存取内存，我们将上述这些存取单位称为内存存取粒度.
>
> 现在考虑4字节存取粒度的处理器取int类型变量（32位系统），该处理器只能从地址为4的倍数的内存开始读取数据。
>
> 假如没有内存对齐机制，数据可以任意存放，现在一个int变量存放在从地址1开始的联系四个字节地址中，该处理器去取数据时，要先从0地址开始读取第一个4字节块,剔除不想要的字节（0地址）,然后从地址4开始读取下一个4字节块,同样剔除不要的数据（5，6，7地址）,最后留下的两块数据合并放入寄存器.这需要做很多工作.

epoll 两种触发方式

Linux 服务器和一台数据库服务器失去连接如何排查？

索引的好处与坏处

加强数据结构和算法

合并两个有序链表

线程和进程的区别

### 阿里云弹性云计算2021-02-10

判断二叉搜索树

### 阿里数字供应链

0221 已投简历 拉进群了hujun.xhj@cainiao.com

### 阿里oceanbase数据库

0221 已投简历lixia.yq<lixia.yq@antfin.com>

### 阿里钉钉

0222 投简历

### 阿里后台珀熙推荐02-22

0222 直接微信发给简历



## LRU缓存

```c
struct LinkNode {
    int key, value;
    LinkNode* prev;
    LinkNode* next;
    LinkNode() : key(0), value(0), prev(nullptr), next(nullptr) {}
    LinkNode(int _key, int _value) : key(_key), value(_value), prev(nullptr), next(nullptr) {}
};
class LRUCache {
private:
    unordered_map<int, LinkNode*> cache;
    LinkNode* head;
    LinkNode* tail;
    int size;
    int capacity;
   
public:
    LRUCache(int _capacity) : capacity(_capacity), size(0) {
        head = new LinkNode();
        tail = new LinkNode();
        head->next = tail;
        tail->prev = head;
    }
    
    int get(int key) {
        if (!cache.count(key)) {
            return -1;
        }
        // 如果 key 存在，先通过哈希表定位，再移到头部
        LinkNode* node = cache[key];
        moveToHead(node);
        return node->value;
    }
    
    void put(int key, int value) {
        //1\如果key不存在，添加进去
        if (cache.count(key) == 0) {
            LinkNode* node = new LinkNode(key, value);
            cache[key] = node;
            node->next = head->next;
            node->prev = head;
            head->next->prev = node;
            head->next = node;
            ++size;
            if (size > capacity) {
                 LinkNode* tailNode = tail->prev;
                 tailNode->prev->next = tail;
                 tailNode->next->prev = tailNode->prev;
                 cache.erase(tailNode->key);
                 delete tailNode;
                 --size;
            }
        }else{
            LinkNode* node = cache[key];
            node->value = value;
            moveToHead(node);
        }

    }

    void moveToHead(LinkNode* node) {
        node->prev->next = node->next;
        node->next->prev = node->prev;
        head->next->prev = node;
        node->next = head->next;
        node->prev = head;   
        head->next = node;     
    }
 

};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */
```



## 字节

语言
const 关键字的使用场景
static 关键字的使用场景
explict 关键字的使用场景
volatile 关键字的使用场景
什么是多态
虚函数的实现原理
构造函数可以是虚函数吗
析构函数可以是虚函数吗，应用场景
智能指针有哪些，实现原理以及用法
什么是模板特化
new 和 malloc 区别
C++ 内存空间布局
如何限制对象只能在堆上创建
如何限制对象只能在栈上创建
如何让类不能被继承
什么是单例模式，工厂模式
C++ auto 类型推导的原理
泛型编程如何实现的
指针和引用的区别
计算机网络
三次握手和四次挥手
TIME_CLOSE 和 TIME_WAIT 的状态和意义
TCP 如何保证可靠传输
流量控制和拥塞控制
CRC 循环校验的算法
如何使用 UDP 实现可靠传输
为什么不能是两次握手
SYN FLOOD 是什么
HTTPs 和 HTTP 的区别
HTTPS 的原理，客户端为什么信任第三方证书
HTTP 方法了解哪些
HTTP 异常状态码知道哪些
HTTP 长连接短连接使用场景是什么
Arp 攻击
NAT 原理
DNS 服务器与提供内容的服务器的区别
怎么实现 DNS 劫持
对称加密和非对称的区别，非对称加密有哪些
AES 的过程
安全攻击有哪些
DDOS 有哪些，如何防范
数据结构
vector 底层实现
如何控制 vector 的内存分配
map, hashmap 底层实现
map 的 key 如果是结构体需要注意什么问题

>注意重载一下 小于大于 符号

hash冲突如何解决
数据库
mysql 索引
B 和 B+ 区别
Redis 的数据结构
Redis持久化
AOF 重写
一致性 Hash
Redis 集群哈希槽
Redis 集群高可用
Redis KEY 过期策略
数据库注入的过程，如何防范
操作系统
进程和线程的区别
进程间的通讯方式
进程切换的上下文细节
线程切换的上下文细节
CPU 的最小调度单位
多线程同步、多进程通信方式
操作系统的栈和堆的区别
用户态和内核态的区别

用户态和内核态切换的代价

从用户态切换到内核态，需要通过系统调用的方式。该过程也是有CPU上下文切换的：切换时，先保存CPU寄存器中用户态的指令位置，再重新更新为内核指令的位置。当系统调用结束时，CPU寄存器恢复到原来保存的用户态。一次系统调用，发生了`两次CPU上下文切换`。

进程切换主要损耗：

1. 指的是CPU寄存器需要保存和加载(单纯切换寄存器影响倒不是特别大)
2. TLB(TLB是一种高速缓存，内存管理硬件使用它来改善虚拟地址到物理地址的转换速度)实例需要重新加载-这个对性能影响非常大不说，整个进程的执行都会停止
3. CPU 的pipeline需要刷掉(cpu 汇编代码优化-汇编代码转换成机器指令由硬件直接实现这一步速度是很快的)
4. 调度器进行线程调度

fork 的过程
内存置换算法
什么是虚拟内存，作用
Select，poll，epoll的区别
epoll 的 LT 和 ET 的区别
什么情况下会发生缺页中断，具体流程
如何判断逻辑地址是否已经映射在物理地址上了
页表所在的位置
环形缓冲区的好处
动态链接和静态链接
怎么查看端口号占用情况
算法
反转链表
多线程交替打印
实现单例模式
最小栈
给定几十万个ip集合，判断任意一个ip是否属于这个集合
给定一个字符串，判断该字符串是否是环等的（字符串首位相连，如果能找到一个位置，从这个位置顺时针得到的字符串和逆时针得到的字符串相等，即为环等）
合并两个排序链表
快排和归并的复杂度分析
排序链表
二叉树中和为某一值的路径
有事洗牌
打家劫舍II
LFU 缓存
乘积最大子数组
车队
用 Rand7() 实现 Rand10()
大整数加法
三数之和
k个不同整数的子数组
快速查找 IP
最小的k个数
二叉搜索树的第k大节点
数组中的重复数字
XML 格式解析
有序数组找到第一个小于0的数和第一个大于0的数
实现一个 string 类
实现一个智能指针
两个排序数组找中位数
无重复字符的最长字串
string 转 float
其他
rebase 和 merge 用法（git）
为了 B 站视频加载更快，可以怎么做

作者：陈乐乐
链接：https://leetcode-cn.com/circle/discuss/mSAtnq/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 腾讯

语言
C 和 C++ 的特点与区别
C++ 的多态是如何实现的
C++ 的虚函数是如何实现的
C++ 的内存管理
C++ 11 有哪些新特性
可变参数模板的作用
malloc 的原理
智能指针有哪几种
如何解决智能指针循环依赖的问题
STL 中 Vector，List 和 Map 的底层原理
inline 的作用
struct 和 union 的区别
static 关键字的用法
C++ 中如何避免拷贝
指针和引用的区别
如何让 .h 文件不被重复引用
怎么防止内存泄漏
new 的作用
delete 和 delete[] 的区别
网络
三次握手和四次挥手的流程
为什么要三次握手，两次握手可以吗
https 的建立连接过程
状态码 301 和 302 的区别
select，epoll，和 poll 的区别
ET 和 LT 的区别
OSI 和 TCP/IP 协议之间的对应关系

### ARP 协议的原理和过程

滑动窗口协议的原理和过程
流量控制和拥塞控制的区别
TIME_WAIT 的作用
TCP 和 UDP 的区别
TCP 如何保证可靠性
SYN Flood 攻击
如何使用 udp 实现可靠性
数据库
redis 的主从复制怎么做的
redis 支持的数据类型
什么是 redis 持久化
redis 有哪几种持久化方式，优缺点是什么
redis 有哪些架构模式
MySQL 中 myisam 与 innodb 的区别

> #### **MyISAM与InnoDB的区别是什么？**
>
> ##### **1、 存储结构**
>
> MyISAM：每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)。
>  InnoDB：所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。
>
> ##### **2、 存储空间**
>
> MyISAM：可被压缩，存储空间较小。支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表。
>  InnoDB：需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。
>
> ##### **3、 可移植性、备份及恢复**
>
> MyISAM：数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。
>  InnoDB：免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了。
>
> ##### **4、 事务支持**
>
> MyISAM：强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。
>  InnoDB：提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。
>
> ##### **5、 AUTO_INCREMENT**
>
> MyISAM：可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，他可以根据前面几列进行排序后递增。
>  InnoDB：InnoDB中必须包含只有该字段的索引。引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。
>
> ##### **6、 表锁差异**
>
> MyISAM：只支持表级锁，用户在操作myisam表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。
>  InnoDB：支持事务和行级锁，是innodb的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。
>
> ##### **7、 全文索引**
>
> MyISAM：支持 FULLTEXT类型的全文索引
>  InnoDB：不支持FULLTEXT类型的全文索引，但是innodb可以使用sphinx插件支持全文索引，并且效果更好。
>
> ##### **8、 表主键**
>
> MyISAM：允许没有任何索引和主键的表存在，索引都是保存行的地址。
>  InnoDB：如果没有设定主键或者非空唯一索引，**就会自动生成一个6字节的主键(用户不可见)**，数据是主索引的一部分，附加索引保存的是主索引的值的数据列。
>
> ##### **9、 表的具体行数**
>
> MyISAM：保存有表的总行数，如果select count(*) from table;会直接取出出该值。
>  InnoDB：没有保存表的总行数，如果使用select count(*) from table；就会遍历整个表，消耗相当大，但是在加了wehre条件后，myisam和innodb处理的方式都一样。
>
> ##### **10、 CURD操作**
>
> MyISAM：如果执行大量的SELECT，MyISAM是更好的选择。
>  InnoDB：如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。DELETE 从性能上InnoDB更优，但DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除，在innodb上如果要清空保存有大量数据的表，最好使用truncate table这个命令。
>
> ##### **11、 外键**
>
> MyISAM：不支持
>  InnoDB：支持
>  通过上述的分析，基本上可以考虑使用InnoDB来替代MyISAM引擎了，原因是InnoDB自身很多良好的特点，比如事务支持、存储 过程、视图、行级锁定等等，在并发很多的情况下，相信InnoDB的表现肯定要比MyISAM强很多。另外，任何一种表都不是万能的，只用恰当的针对业务类型来选择合适的表类型，才能最大的发挥MySQL的性能优势。如果不是很复杂的Web应用，非关键应用，还是可以继续考虑MyISAM的，这个具体情况可以自己斟酌。
>
> 存储引擎选择的基本原则
>
> 采用MyISAM引擎
>
> - R/W > 100:1 且update相对较少
> - 并发不高
> - 表数据量小
> - 硬件资源有限
>
> 采用InnoDB引擎
>
> - R/W比较小，频繁更新大字段
> - 表数据量超过1000万，并发高
> - 安全性和可用性要求高
>
> 采用Memory引擎
>
> - 有足够的内存
> - 对数据一致性要求不高，如在线人数和session等应用
> - 需要定期归档数据
>
> 
>
> 作者：人在码途
> 链接：https://www.jianshu.com/p/a957b18ba40d
> 来源：简书
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

innodb 引擎的 4 大特性
操作系统
进程和线程的区别
进程间的通信方式有哪些
在一台内存为 2G 的机器上，使用 malloc 分配 20G 会发生什么，new 20G 呢

> - 首先，malloc和new申请的都是虚拟内存。和物理内存没有直接关系
> - 每个进程允许的虚拟内存是4G，如果是20G的话，已经超出了4G这个上限，无法申请。
> - new的话，底层实现还是malloc，在分配失败的时候会抛出bad_alloc类型的异常

什么是孤儿进程，僵尸进程，惊群效应
Ubuntu 开机过程中系统做了哪些事情
堆和栈的区别
乐观锁和悲观锁
如何监控进程异常退出
线程怎么将一个全局变量变成私有变量

### 两个不同的进程同时使用一个端口号有没有问题

```c
每个进程分别绑定不同的网卡地址的同一端口
第一个进程先绑定到监听地址端口, 然后 fork 子进程共享使用
每个进程都使用 SO_REUSEPORT 选项,然后绑定同一个地址和端口
(Linux kernel 3.9带来了SO_REUSEPORT特性。
SO_REUSEPORT支持多个进程或者线程绑定到同一端口，提高服务器程序的性能，解决的问题：
允许多个套接字 bind()/listen() 同一个TCP/UDP端口
每一个线程拥有自己的服务器套接字
在服务器套接字上没有了锁的竞争
内核层面实现负载均衡
安全层面，监听同一个端口的套接字只能位于同一个用户下面
以前通过fork形式创建多个子进程，现在有了SO_REUSEPORT，可以不用通过fork的形式，让多进程监听同一个端口，各个进程中accept socket fd不一样，有新连接建立时，内核只会唤醒一个进程来accept，并且保证唤醒的均衡性。)
```

虚拟内存的原理
算法
数据流的中位数
二叉树的最近公共祖先
编辑距离
最长公共子序列
合并两个排序的链表
删除排序链表的重复元素
二叉树中和为某一值的路径
二叉排序树的第k大节点
数字转换为十六进制数
反转链表
两个栈实现队列
环形链表 II
排序算法的稳定性是什么
x 的平方根
二叉搜索树与双向链表
一个升序再降序的数组，找到最大值

作者：陈乐乐
链接：https://leetcode-cn.com/circle/discuss/5dPCGA/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 网易

语言
写一个常量指针和指针常量
怎么实现单例模式
单例模式和观察者模式的应用场景
reactor 模式
MVC
了解其他开源的 mallic 方式吗
C++ 14 新特性
C++ 20 新特性
什么是右值引用
什么是智能指针，有哪些，以及实现原理
什么是虚函数
怎么定义虚函数
什么是虚函数表
什么是多态
指针和引用的区别
指针的大小
强制类型转换
如何理解 C++ 的面向对象编程
内存对齐的原则
怎么实现模板
指针和 const 的用法
内联函数和宏定义的区别
extern C 的作用
C 和 C++ 的区别
模板特化的概念，为什么特化
explicit 干什么用的
new与malloc的 区别，delet 和 free 的区别
vector 底层如何实现的，如果内存不够执行什么操作
sizeof(1==1) 在 C 和 C++ 中分别是什么结果
计算机网络
长连接和短连接
怎么在服务端实现长连接
http 和 https 区别，https 加密方式
http 头部包含哪些，keep-alive 和非 keep-alive 区别，对服务器性能有影响吗
怎么知道 http 的报文长度
如果你访问一个网站很慢，怎么排查和解决
域名和 ip 的关系，一个 ip 可以对应多个域名吗
为什么 fidder，charls 能抓到你的包，过程是什么
tcp 三次握手和四次挥手
TIME_WAIT状态会导致什么问题，怎么解决
tcp 如何保证可靠传输
ping ip 的过程
拥塞控制和流量控制
tcp 和 udp 的区别
tcp 粘包问题
tcp 报文包含哪些信息
如果不想让一个人上网，除了MAC地址进行限制之外还能怎么做
私网地址和公网地址之间进行转换：同一个局域网内的两个私网地址，经过转换之后外面看到的一样吗
对称加密和非对称加密的区别
epoll水平触发和边沿触发，底层原理
数据结构
跳表的实现原理
哈希表的具体实现，哈希函数和哈希冲突等
字典树的实现原理
红黑树的定义和解释
二叉树有哪几种遍历方式
map 与 unorder_map 的区别
vector 和普通数组的区别
数据库
MySQL、MongoDB 区别以及适用场景
MySQL 有哪些存储引擎以及它们的区别和适用场景
Redis 有哪些对象，什么情况用什么对象
Redis 中的跳跃表
Redis 和关系型数据库比有什么特点
Redis 中是怎么避免突然断电等数据丢失的问题的
数据库的事务特点
数据库的隔离级别
分表和分区
假如查询的字段不是你分区的字段，如何提高效率
数据放在内存中的数据库有什么隐患
bin
操作系统
linux 内核原理了解哪些
Linux 文件系统
哪些方法可以读取文件内容
共享内存的实现原理
进程怎么进行管理
进程间的通讯方式
进程和线程的区别
系统平均负载如何计算
read 函数详细调用过程
怎么通过 inode 节点的文件偏移量知道读取哪个页
当页缓存未命中时会发生什么
怎么样知道该页的磁盘地址
如何实现内存池
如何检测出现了内存碎片，如何解决
如何检测内存泄漏
实现多线程有哪些方法
多线程的缺点
互斥锁和自旋锁的区别和优点
死锁如何产生
堆和栈的区别和优点
有哪些调度算法
内存溢出有那些因素
异常机制
top 怎么查看线程
Linux下的/var 目录有什么用
什么是并行计算
算法
反转链表
合并两个有序链表
快速排序的实现原理
strcpy 函数的实现
链表中的倒数第k个节点
海量 url 去重
二叉树的镜像
最短路径算法 （Dijkstra和floyd算法）
网格中的最短路径
前k个高频元素

作者：陈乐乐
链接：https://leetcode-cn.com/circle/discuss/0BJL7O/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 美团一面凉经

自我介绍
介绍自己做的有成就感的一件事
数据库的行锁底层是怎么实现的
数据库是什么引擎？
智力题：有很多不均匀（长度、粗细不同）的香，每根香都可以燃烧一个小时，如何精准的计算半个小时？（用两根香，一根香两头同时点，另一根香只点燃一头，当第一根香燃烧完毕时，这时候刚好半小时）
问项目：模型的评估的指标？
Linux 命令：看CPU的使用情况top命令
什么是死锁？
手撕代码：判断链表中有没有环？
设计模式 ？简单介绍几个设计模式
http状态码？
tcp三次握手
面经总结
数据库：

聚簇索引和非聚簇索引的区别？使用场景
MySQL数据库的索引有哪些？
什么情况下建议使用索引？
索引的引擎？分别有什么区别
MySQL分页原理
主键索引和辅助索引有什么区别？有什么联系
数据结构：

B+树和B树的区别？优缺点？应用场景
哈希冲突如何解决？
红黑树的特点？
红黑树的左旋右旋？
链表和数组的区别？
操作系统：

IO多路复用的实现方式
BIO 和 NIO 是什么？
进程和线程的区别？
什么是协程？协程的轻量级体现在哪里？
同步和异步的区别？阻塞和非阻塞的区别
计算机网络：

介绍五层模型以及相应的协议？
HTTP和HTTPS的区别？
HTTPS是如何保证安全的？
cookie和session的区别？
Http的状态码？（这里面试官会挑其中的几个问）
线程池
TCP如何实现可靠传输？
浏览器中输入了url到网页显示的完整过程？整个过程涉及到了哪些协议？
C++:

多态是如何实现的？
虚函数和纯虚函数的区别？
虚函数实现的原理？
动态链接和静态链接？二者的区别？
函数指针和指针函数的区别？
vector的底层原理？如何进行容量扩增？
指针和引用的区别？
struct和class的区别？
重载和重写的区别？
面向对象和面向过程的区别？

作者：Crystal
链接：https://leetcode-cn.com/circle/discuss/SdQ4FO/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

**学习路线及时间安排**

推荐时间为4个月，包括四部分：语言，计算机基础知识，项目基础知识，项目实践。

- 语言
  - 推荐学习**1个月**
  - 学习方针：**视频为主，书籍为辅**。
  - 配套视频：C语言，C++语言
  - C++ Primer Plus
    - 集中学习该书的1~8章，涉及C语言基础语法及指针、结构体的使用。
  - C和指针
    - 该书全面深入的剖析了指针的概念与使用，是C语言的进阶。
  - C++ Primer
    - 作为C++查询的工具书，相当于新华词典，里面会涉及C++的很多技术细节，实际工程中用到的并不会太多。平时遇到问题可以查询该书，另外也可以作为面试的参考书。
  - STL源码解析
    - 涉及C++标准模板库的源码实现，其中vector、map的实现需要重点关注，比如内存分配，底层数据结构等。

![img](https://i.loli.net/2020/04/06/KLTtj4OUFo1YPBl.jpg)

- 计算机基础知识
  - 推荐学习**1个月**
  - 配套视频：数据结构
  - 数据结构
    - 视频为主，书籍为辅。看小甲鱼的数据结构，该视频以大话数据结构为蓝本讲解，了解链表，栈，队列，二叉树，哈希表，堆等基础的数据结构。
  - 算法
    - 推荐直接刷题，先临摹再实战。推荐书籍剑指offer，左程云大神的程序员代码面试指南；刷题网站推荐牛客网。
  - 操作系统
    - 推荐书籍学习，重点看深入理解计算机系统的6,7,9,10章。主要理解线程，进程，虚拟内存及锁机制。
  - 计算机网络
    - 推荐书籍学习。主要理解TCP/UDP/HTTP三种协议。其中TCP/UDP以谢希仁老师的计算机网络为主，HTTP以图解HTTP协议为主。
  - 设计模式
    - 推荐书籍学习，大话设计模式。设计模式可以放在所有知识的最后进行学习。

![img](https://i.loli.net/2020/04/06/a59LbTVXCjpSZM8.jpg)

- 项目基础知识
  - 推荐学习**1个月**
  - 配套视频：Linux，数据库
  - Linux基本命令
    - 该部分主要以看视频为主，记住常用的即可，其余的在实际使用时即用即搜。
  - Linux系统编程
    - 在Linux下进行编程，会涉及到与系统的交互，内存访问，需要学习Linux系统API用法。
  - 网络编程
    - 视频为主，书籍为辅。书籍先看tcp/ip网络编程查漏补缺，补齐网络编程基础知识，然后看Linux高性能编程。
  - 数据库
    - 视频为主，书籍为辅。MySQL和Redis数据库是当前面试的热门，书籍先看MySQL必知必会，再看Redis设计与实现。

![img](https://i.loli.net/2020/04/08/yfI4d3ZG2OCS1il.jpg)

- 项目实践
  - 项目名称为**Linux下C++轻量级Web服务器开发**，实现web端用户注册，登录功能，经压力测试可以实现上万的并发连接。（测试机器为Intel i7 7700，16G内存）
  - 推荐学习**1个月**
  - 线程池
    - 涉及线程，锁机制。使用一个工作队列完全解除了主线程和工作线程的耦合关系：主线程往工作队列中插入任务，工作线程通过竞争来取得任务并执行它。
  - HTTP请求与响应
    - 涉及Linux系统编程，网络编程，TCP和HTTP协议。根据状态转移,通过主从状态机封装了http连接类。其中,主状态机在内部调用从状态机,从状态机将处理状态和数据传给主状态机。
  - 注册登录
    - 涉及少许网页html知识。实现用户名和密码校验，另外通过html文件设置action实现跳转。
  - 定时器
    - 涉及Linux系统信号及数据结构的使用。由于非活跃连接占用了连接资源，严重影响服务器的性能，通过实现一个服务器定时器，处理这种非活跃连接，释放连接资源。
  - 数据库连接池
    - 涉及MySQL数据库。建立数据库连接池，通过重复使用这些已经建立的数据库连接，解决频繁建立连接的缺点，从而提高系统性能。
  - 同步/异步日志系统
    - 涉及设计模式，自定义阻塞队列。同步/异步日志系统主要涉及了两个模块，一个是日志模块，一个是阻塞队列模块,其中加入阻塞队列模块主要是解决异步写入日志做准备。
  - 压力测试
    - 阅读Webbench源码，对进程加深理解。通过Webbench创建多个进程，每个进程通过HTTP连接访问服务器，完成压力测试。

![img](https://i.loli.net/2020/04/06/kLdZQ8JRPCfE3bm.jpg)

------

相关资料电子书链接：https://pan.baidu.com/s/1dD_F6aG5dIetaks0kIobAg提取码：buim
视频链接：https://pan.baidu.com/s/1tri7oj_R_J4QU__8RjZq7w提取码：emtp
项目Linux下C++轻量级Web服务器https://github.com/qinguoyi/TinyWebServer
知识总结https://github.com/twomonkeyclub/BackEnd

-----



作者：这波有什么问题
链接：https://www.nowcoder.com/discuss/379063?type=all&order=time&pos=&page=1
来源：牛客网

1自我介绍
 2实习项目（问的挺详细的），实习学到了哪些东西
 3看过哪些c++的书，印象最深的是哪个？具体是什么方面
 4除了看书还通过哪些渠道学习c++？有没有喜欢的博主？有没有自己写过博客？
 5虚函数的实现原理？
 6析构函数有没有必要都设置成虚函数？为什么？
 7Socket编程了解过吗？
 8网络的知识了解的多吗？说一下tcp连接和释放的过程？
 9Vector的底层实现原理？STL容器哪些用的比较多
 10map和unorder_map的底层实现和区别？
 11哈希表的实现原理?如何解决哈希冲突？哪种方法更好？

  12有什么方法可以避免申请的内存忘记被释放？

-----



作者：Buermy
链接：https://www.nowcoder.com/discuss/394076?type=0&order=0&pos=1&page=1
来源：牛客网

一面:电话面
1.自我介绍;
2.你是非科班的，说一下你的自学过程;
3.简单介绍一下你的项目;
4.项目用到了epoll，讲一下epoll的ET模式和LT模式;
5.讲一下epoll的oneshot?
6.惊群效应;
7.有什么想问的吗?
这一面感觉就是简单聊天

二面:视频面
1.介绍一下项目;
2.项目用到了线程池，如何避免多线程的同步错误?
3.线程间的通信机制;
4.项目用到了stl，从源码角度讲一种你熟悉的stl容器的实现?map与unordered_map的底层数据结构与查找复杂度;
5.项目是用Cpp11写的吗?讲一下Cpp11的新特性?
6.讲一下智能指针为何能避免内存泄露?为什么匿名函数能提高程序效率?
7.你的http报文解析是怎么做的?用到了什么数据结构?如果http应答报文大于你设定的写缓冲区怎么处理?
8.既然tcp更可靠，为什么有很多项目还是优先选择udp?udp快在哪里?如何保证udp的可靠性?
9.libevent了解过吗?讲一下libevent的原理;
10.内存对齐;
11.虚函数工作原理;
12.什么时候用模板函数?什么时候用虚函数?
13.Cpp 类对象的内存分布;
14.手撕LRUmap
这一面主要面基础

三面:视频压力面
1.介绍一下你的项目;
2.你写的服务器性能怎么样?
3.服务器压力测试怎么做的?
4.服务器吞吐量?
5.服务器响应时间?
6.如何减少响应时间?
7.如何确定服务器的最大并发连接数?
8.讲一个你做过的一个确实能用的项目;
9.还有什么问题吗?
这一面节奏很快，如果不能很快答出来就立刻跳到下一个问题，而且面试官很严肃

四面:电话hr面
1.做一下自我介绍;
2.你在一年时间内又要做项目又要自学计算机基础又要打比赛，时间是怎么分配的?
3.你是哪里人?未来打算在哪里发展?
4.现在拿到几个offer了?
5.最早能过来实习的时间?实习时长?
6.还有什么要问的吗?
hr小姐姐人很好，感觉放轻松聊天就好了

-----

作者：A1kaid
链接：https://www.nowcoder.com/discuss/395060?type=0&order=0&pos=13&page=1
来源：牛客网



事业群：CSIG 在线教育部

Base：深圳

技术栈：半路出家学了半年的C++、学了一年的Python

个人项目是烂大街的服务器和一个外包🤣

团队项目是两个和数据挖掘相关的项目🤣

## 电话一面(40min)

项目介绍
小根堆计时器是怎么样的机制
优先队列和map的区别是什么
vector的内部结构
如何避免vector的动态扩容
vector越界访问会怎么样
红黑树的规则
红黑树的增删改查的时间复杂度
往map里面增加或删除元素是怎么实现的
智能指针是自己实现的吗
如何实现智能指针
智能指针的引用计数如何确保线程安全
怎么实现原子操作
RAII机制具体是什么含义
日志系统的相关问题
线程池是怎么使用的
长连接过程中线程一直持有连接对象吗
有用过什么数据库
数据库的字段类型是如何设计的
用的是什么数据库引擎
Innodb和MyISAM的区别
varchar最大长度是多少
varchar如果长度超过了怎么办
Linux常用的命令
压测如何查看在哪里达到瓶颈
有什么问题？

总结：一面的时候挺突然的，所以也没多准备，主要围绕的是简历上的项目来问，中间夹杂着一些基础的询问，所以最终结果也还好，最后询问的时候面试官也肯定了我的C++基础不错，并且说了会有下一面。

## 视频二面(40min)

自我介绍
有用过部门的产品吗？
讲一讲团队项目？为什么要使用这些算法？算法是如何挑选的
讲讲DBSCAN和KMeans算法的区别，讲一下你理解的DS证据理论
介绍项目
EPOLL和Select的区别
为什么要使用边缘触发模式
EPOLL ET和LT的区别
ET模式下，要遵循哪些规范
Reactor和Proactor模式的区别
如何保证线程安全
请求进入之后是如何处理的
Time-wait状态过多会有什么后果，怎么处理？
长连接和短连接之间是如何处理的
为什么采用小根堆的优先队列作为定时器
对请求报文的解析是自己写的还是调用库，难度在哪
日志系统是如何保证高并发的
日志系统如何保证线程安全
有看过其他开源服务器吗
Nginx的请求处理流程
目前有投什么公司
为什么CVTE刷了你 (HR面刷的- -无语)
头条和腾讯选择哪个

总结：一开始的时候也没想到面试官会问我的团队项目里面的算法内容- -不过好在之前有特地的去看过相关的，所以答的也还算是流畅。可能是因为这个所以整个面试流程下来完全没撕代码？



作者：徐皖辉
链接：https://www.nowcoder.com/discuss/407325
来源：牛客网



4.14日 早上看了下状态已灰...只能等正式批笔试再试试了，大家都加油!

​	

​	之前被一个师兄坑了，4,1号才在官网投的简历，等了大概一周才有面试机会，结果一面有点凉凉，难受...

​	1. 自我介绍

​	2. C++中的智能指针有哪些（shared_ptr,unique_ptr,weak_ptr）

​	3. shared_ptr指向一个动态数组需要注意什么（我不知道，就猜测性的答了一下，回来百度发现说错了...正确说法是需要注意指定删除函数delete[]，默认的delete会导致内存泄露）

​	4. static关键字定义静态成员数据、函数的作用（对象共享）

​	5. 静态成员函数能否调用非静态成员函数（不能，生存周期不同，且静态成员函数没有this指针，无法调用，我当时是根据它们在内存的分布来答的，有点混乱...），非静态成员函数调用静态成员函数（只能通过类名调用）

​	6. int i = 0; i++=6合法吗（不合法，为什么？求个大佬解答，我知道表达式不能赋值）；++i=6合法吗（合法，i=6，为什么？）（我当时答反了，我说的++i=6是右值不能赋值，i++=6先赋值再做+1操作，完全错了，面试官只点头说恩...无语了）

​	7. 编程题1：最长不重复子串（A了，比较简单，有多种方法，我使用hashmap实现的，没要求空间复杂度O(1)）

​	8. 编程题2：将单链表的每k个节点反转（思路简单，我按照链表反转的思路写出来了，但是运行一直有问题，调bug一直没调出来，最后时间差不多，就叫停了）

​	9. linux命令：修改文件权限（chmod 777 file）

​	10. linux命令：查看内存或cpu（top）

​	11. mysql主从复制的方式（1.基于 SQL 语句的复制(statement-based replication, SBR);2.基于行的复制(row-based replication, RBR)；3.混合模式复制(mixed-based replication, MBR);4.基于 SQL 语句的方式最古老的方式，也是目前默认的复制方式，后来的两种是 MySQL 5 以后才出现的复制方式）(我说成复制方式（异步复制，全同步复制，半同步复制），方向都错了，真的不太了解的不能乱答，数据库主备这块确实不太熟悉)

​	12. 一个进程里面的多线程，如果其中一个线程挂掉了，影响其他线程吗（一个线程挂掉，其他线程也挂掉）（比较完整缜密的说法是：1.如果进程不屏蔽 segment fault 信号，一个线程崩溃，所有线程终结。2.如果屏蔽 segment fault 信号，且线程崩溃的位置是线程私有位置（stack），那么其他线程没有问题。3.如果屏蔽 segment fault 信号，且线程崩溃的位置是线程共享位置（heap、全局变量等），那么其他线程也会出现问题。）

​	可能还有一点比较简单的问题，我不太记得了...历时应该是超过1个小时了。

​	

​	结束时问了我能实习多长时间，然后就是告知等待后续的通知。

​	挺凉的，没有把握的问题，回答错了，不应该这么草率的，感觉面试官最讨厌乱答的人，还不如直接说不知道（主要是我觉得我这样orz...）。编程题第二道没做出来，还浪费了好多时间，唉，感觉后面就是问我几个比较简单的来结束面试了。

​	面试结束后看了个人主页，暂时还没灰，先等等吧，太菜了，真的不行啊！

​	过来发牛客，求个二面！

作者：王°
链接：https://www.nowcoder.com/discuss/407296?type=2&order=1&pos=10&page=1
来源：牛客网

1.tcp流量控制跟拥塞控制
 2.进程通信方式、进程调度方法、进程跟线程区别
 3.mysql索引引擎区别，数据库三大范式
 4.java内存模型、GC回收算法跟垃圾收集器
 5.java接口跟抽象类区别
 6.linux 查看进程信息、端口占用命令
 7.工厂模式，编码
 8.算法题

  LRU、求树高，环形链表入环几点

作者：健康成长天线宝宝啊
链接：https://www.nowcoder.com/discuss/147538
来源：牛客网

后台开发包括的知识点很多，包括语言基础，算法，linux编程基础，linux内核，网络，数据库，分布式等等。面面俱到很难，一个领域钻研的很深也很难。我认识的大神里有把C++语言吃的非常透的，也有实验室就是搞分布式的，拿offer都非常轻松。


 秋招拿到：
 字节跳动后台开发
 网易游戏游戏研发
 阿里云基础平台开发
 华为
 腾讯后台开发

 我准备应聘的时间从研一的寒假开始，当然自己探索的路上走了不少弯路。

 列举一下自己的学习内容中我自己认为对找工作或者对提升自己非常有帮助的一些书或资料，仅供参考~


 语言基础，C++语言相关的：

 《C++ Primer》，应该算是工具书，但我花了3个月一个字一个字啃完了，现在能记住的没几个了，但是好在全看完就不用看Effective C++了，基本都包含在内了。

 《STL源码剖析》，很老的书了，很多内容都过时来了，比如空间配置器，但是面试官还是会问……可以跟面试官讲讲ptmalloc的实现。整本书都是重点。

 《深度探索C++对象模型》，虽然基本只会问虚函数的实现，看一篇博客也能应付面试，但是还是建议多看几遍。

 《Effective C++:改善程序与设计的55个具体做法》还有more effective C++，建议快速看一下。

 STL和对象模型我都看了3遍以上，因为太容易忘了，Effective C++只是快速浏览了一遍，发现基本都包含在Primer里了。



 网络，除了本科学过的(《计算机网络 自顶向下方法》)，我看了《TCP/IP详解卷1》12-16章，重点是TCP、IP、UDP，其它部分看书太麻烦了，直接从博客里看了。



 linux环境编程apue和unp两本是必须的，因为太厚了，看起来还是有点痛苦的，但是不需要全看，而且内容重叠很多。unp卷1前面8章是重点，卷2前面4部分都挺重要的，apue全部，先是要有个概念，自己写代码的时候就知道哪块重要了。


 此外，《后台开发：核心技术与应用实践》是腾讯的员工写的，虽然这本书评价比较差，几乎都是抄的博客，但是内容上总结的很好(我觉得就是给校招的同学写的)，都是后台开发需要的基础知识的总结，这本书中内容所代表的知识，基本都是腾讯的C++后台开发工程师所必备的基础，可以作为一个复习提纲。



 下面的书应该算是提高篇了：


 linux内核相关，我买了《深入理解linux内核》发现啃不动，后来看了《linux内核设计与实现》，非常推荐，外加一大堆博客，《深入理解计算机系统》讲的东西比较简单，这个可以作为一个补充，面试官问的很多操作系统相关的问题书中都有涉及。


 《Linux多线程服务器端编程》，陈硕的书，讲muduo网络库的，我看了3.4遍，源码也读了3.4遍，收获非常多。前面部分是后台开发的一些经验之谈，对面试也很有用。

 《Redis设计与实现》看完感觉也特别好，很值得学习，可以很快就看完。有很多重要的数据结构可以在面试的时候讲出来，比如跳表、redis的 hash表啦~

 《深入理解Nginx》我也看了一部分，nginx太经典了，很多面试官也都提到过。

 短小精悍的源码还非常推荐leveldb，对照博客把leveldb源码看完不需要多长时间(我花了两个周吧)，但是收获非常多。在此基础上还可以了解一下rocksdb。

 除此之外，还看过一些其它的书，感觉不值得推荐就不写了。



 书是比较系统性的东西，博客通常是总结性的东西，也是对书中内容的一个补充吧。好多东西面试会问到，但是书中很难找到解答，对照着网上的面经搜博客吧。我看了下自己收藏夹里的光是收藏的博客就已经上百篇了，当然还是不能完全覆盖面试官会问到的问题。(这一步是重点啊)

 分享一下我自己看过的博客，从手机书签里导出来的，整理了一下：

http://www.linya.pub/



 算法

 我只刷了Leetcode上的500多题，但是第一遍不会的题都标记了，后面又刷了很多遍。《剑指offer》这种书不太建议看，很啰嗦，解答也不如LeetCode上的高票解答。直接干刷其实还有点无聊的，每周日上午做一下leetcode的周赛也是个不错的选择，可以当做模拟笔试/面试。另外 Top 100 Liked Questions 可以重点关注一下。



 项目

https://github.com/linyacool/WebServer



  写了一个静态Web服务器，主要是找实习的时候用的，参考了muduo网络库。 

  

  仅供参考！仅供参考！仅供参考！(不要直接拿去面试，你如果自己想做一点东西，有非常多非常多可做的事情，千万不要把github里的描述直接写进简历，结果一问三不知)

![](https://i.loli.net/2020/04/29/lIpQXDn3PG7HLvN.png)







![image-20200325222316687](https://i.loli.net/2020/03/30/iTNkvDM97sZX6dW.png)



## 阿里云



  \1. 指针和数组啥区别 内存里怎么访问的 （mov 数组的话基址+offset） 
 \2. 内存访问一个int 和访问一个int数组啥区别 x86下向量化指令SIMD用过没（见过没写过） arm访存指令 （load/store） 
 \3. 声明一个数组 在内存里咋样 （推esp） 
 \4. voliate关键字 （强行写回内存 防止未定义操作） 
 \5. 结构体 在内存中 怎么存放的（x86下按4字节对齐）为啥 （减少访存次数） 
 \6. pthread_create 
 \7. epoll 内核原理。。从网卡收到一个包开始讲起。。（我艹） 
 \8. 建堆 时间复杂度 
 \9. malloc sbrk的内存里机制 mmap 文件映射 匿名映射 munmap 为啥munmap能直接释放一段内存 内核怎么实现的 （三句话不离内核 我吐了） 
 \10. 进程 线程 （进程：通用寄存器+状态寄存器+浮点寄存器+...+整个虚拟地址空间；线程：线程栈+一部分寄存器） 
 \11. x86 调用寄存器 被调用寄存器 （忘了。。口胡了个ebx ecx被告知了正确答案） 
 \12. 讲了讲jemalloc结构 为啥jemalloc分配和释放快 
 \13. gdb 命令 （讲了gdb调试clang） 有没有用gdb调过汇编 （我：gdb还能调汇编？？？） 
 \14. git 命令 rebase用过没 git机制 怎么实现的 （讲了个bisect 他也没用过hhhh 正常就clone tag show log push commit fetch pull） 
 \15. strace ；perf 原理是啥 （不晓得）除了函数统计 微架构相关数据关注过没？（研究过 L1 cache miss） 

  \16. 算法题





![image-20200519165622062](https://i.loli.net/2020/05/19/d8CQmalZx9ELeUq.png)

![image-20200519165630798](https://i.loli.net/2020/05/19/MxoOuVLtbZGlYfP.png)

-    说下TCP断开连接（TCP四次挥手，从客户端开始断开连接说的。）close wait 和time wait分别在哪边？啥作用？假如是服务器先断开连接那time wait状态是在服务器那边吗？（我也不清楚，吞吞吐吐说是）
-    java 多线程写过没有？线程怎么保证安全？（好像是这么问的，说上锁？？ 然后举了个i++自增的例子）
-    红黑树和二分查找复杂度，hash表复杂度，为什么？（O（1）,然后说了如果冲突了一般会用拉链法，一个拉链若有N个结点的话，在这个拉链上查找就变成了o(n)，然后又问如果是用拉链法的话总体时间复杂度是多少（我开始说O(1)，说理由感觉有点懵了，后面说这不是跟拉链长度有关嘛）然后问，拉链要是太长了怎么办（转成树结构），hash表要是太满了如果每一个拉链都特别长呢？（扩容，重新放置元素）还有其他解决冲突的方法没有？（冲突了直接找下一个空闲位置，这个好像叫线性探测法？）
-    进程和线程的区别；同一个进程中的线程共享哪些资源，哪些是独占的。线程是怎么进行切换的。
-    2G内存是怎么运行4g的程序？回答的时候说到，需要用到的页要调入内存，遂问，你怎么知道需要用到哪一页？（我说程序都是顺序存放的，巴拉巴拉，也不知道对不对😂）
-    （数据库熟不熟？我说只会一些基本操作）索引是什么（我好像只会说索引的作用是啥，是什么就。。。）
-    有哪些索引？什么是聚簇索引？他的叶子节点和非叶子节点都放了什么？B+树索引有什么特点，好处？为什么不用二叉树？
-    你算法怎么样？（我说我也不知道😂）遂出了这题：加入迈台阶一次可以迈1或2或3步，100阶的台阶有多少种走法？



## [5211. 概率最大的路径](https://leetcode-cn.com/problems/path-with-maximum-probability/)

## 三数之和O n

## [仅含 1 的子串数](https://leetcode-cn.com/problems/number-of-substrings-with-only-1s/)

这道题是字节跳动的周赛题，我原先是使用统计出现连续字符的数量，放进一个容器里，然后用等差数列求和的方式来统计的；但是感觉过于复杂，代码如下：

```c
class Solution {
public:
    int numSub(string s) {
        int n = s.size();
        int count = 1;
        vector<int> num;
        int res
        for(int i = 0; i < n; ++i){
            if(s[i] == s[i+1]){
                count++;
            }
            else{
                num.push_back(count);
                count = 1;
            }
        }
        num.push_back(count);
        for(auto it : num){
            res = res + it*(it+1)/2;
        }
        return res;
    }
    ------这个是统计0和1所有字符出现的次数的与题目不是很符合，所以我就改了半天
class Solution {
public:
    int numSub(string s) {
        int n = s.size();
        int count = 1;
        vector<int> num;
        long long  res=0;
        for(int i = 1; i < n; ++i){
            if(s[i] == s[i-1] && s[i] == '1' && s[i-1] == '1'){
                count++;
            }
            else if(s[i] == '0' && s[i-1] == '1')
            //else
            {
                num.push_back(count);
                count = 1;
            }
        }
        if(s[n-1] == '1')
        num.push_back(count);
        for(auto it : num){
            
            long long tmp = it;
            
            //(it*(it+1) / 2) % (1000000007);
            cout << it << " ";
            res = (res + tmp*(tmp+1) / 2) % (1000000007);
        }
        return res;
    }  
}  ; 
```

这个才是比较轻便的做法：

```c
class Solution {
public:
    int numSub(string s) {
        int n = s.size();
        int mod = 1e9 + 7;
        long long res = 0;
        for(int i = 0; i < n; ++i){
            if(s[i] == '1'){
                int j = i;
                long long  len = 0;
                while(j < n && s[j] == '1'){
                    len++;
                    j++;
                }                
                long long tmp = (len * (len + 1) / 2) % mod;
                res = (res + tmp) % mod; 
                cout << len << ' ';               
                i = j;
            }
        }
        return res;
    }
};
```

# 操作系统

- linux的内存管理机制，内存寻址方式，什么叫虚拟内存，内存调页算法，任务调度算法
- 锁：互斥锁，乐观锁，悲观锁
  - 死锁必要条件及避免算法
- 动态链接和静态链接的区别
- 常见的信号、系统如何将一个信号通知到进程
- linux系统的各类同步机制、linux系统的各类异步机制
- 如何实现守护进程
- 标准库函数和系统调用的区别

# linux 服务器

- 32位系统一个进程最多有多少堆内存
- 五种I/O 模式:阻塞I/O,非阻塞 I/O,I/O 多路复用,信号驱动 I/O,异步 I/O
  - select 模型和 poll 模型，epoll模型
  - socket服务端的实现，select和epoll的区别(必问)
  - epoll哪些触发模式，有啥区别？
- 用户态和内核态的区别
- linux文件系统：inode，inode存储了哪些东西，目录名，文件名存在哪里

# 计算机网络

- TCP和UDP区别
- TCP和UDP头部字节定义
- TCP和UDP三次握手和四次挥手状态及消息类型
- time_wait，close_wait状态产生原因，keepalive
- 什么是滑动窗口，超时重传
- 列举你所知道的tcp选项
- connect会阻塞检测及防止，socket什么情况下可读？
- socket什么情况下可读？
- connect会阻塞，怎么解决?(必考必问)
- keepalive是什么？如何使用？
- 长连接和短连接
- UDP中使用connect的好处
- DNS和HTTP协议，HTTP请求方式

## CMakeLists.txt



```cmake
cmake_minimum_required(VERSION 3.5)# 规定最低版本

project(CloudViewer) # 项目名称

# init qt
set(CMAKE_AUTOMOC ON) # for meta object compiler
set(CMAKE_AUTORCC ON) # resource files
set(CMAKE_AUTOUIC ON) # UI files

# find package
find_package(Qt5 REQUIRED Widgets)
find_package(PCL 1.7.1 REQUIRED)

include_directories(${PCL_INCLUDE_DIRS})# 将PCL_INCLUDE_DIRS（上面find 到了） 文件夹下的头文件加入到包含路径中，类似于加入到VC++--->包含目录
link_directories(${PCL_LIBRARY_DIRS})# 同理，链接--》库目录
add_definitions(${PCL_DEFINITIONS})

# find source files, header files and ui files
# aux_source_directory(. DIR_SRCS)
file(GLOB_RECURSE DIR_SRCS    ${CMAKE_CURRENT_SOURCE_DIR}/*.cpp)#GLOB_RECURSE 将会递归所有匹配文件夹的子文件夹和匹配的文件。将结果保存到变量里面去供下文使用
file(GLOB_RECURSE DIR_HEADERS ${CMAKE_CURRENT_SOURCE_DIR}/*.h)
file(GLOB_RECURSE DIR_UIS     ${CMAKE_CURRENT_SOURCE_DIR}/*.ui)

# add resource
set(RESOURCE ${CMAKE_CURRENT_SOURCE_DIR}/CloudViewer.qrc)
qt5_add_resources(RESOURCE_ADDED ${RESOURCE})
# 相当于 GCC -o ${PROJECT_NAME} ${DIR_SRCS}...
add_executable(${PROJECT_NAME}
    ${DIR_SRCS}
    ${DIR_HEADERS}
    ${DIR_UIS}
    ${RESOURCE_ADDED}
)
# 相当于 GCC -o ${PROJECT_NAME} -l${PCL_LIBRARIES}
target_link_libraries(${PROJECT_NAME}
    ${PCL_LIBRARIES}
    Qt5::Widgets
)

```

### find_package原理

首先明确一点，cmake本身不提供任何搜索库的便捷方法，所有搜索库并给变量赋值的操作必须由cmake代码完成，比如下面将要提到的FindXXX.cmake和XXXConfig.cmake。只不过，库的作者通常会提供这两个文件，以方便使用者调用。

find_package采用两种模式搜索库：

Module模式：搜索CMAKE_MODULE_PATH指定路径下的FindXXX.cmake文件，执行该文件从而找到XXX库。其中，具体查找库并给XXX_INCLUDE_DIRS和XXX_LIBRARIES两个变量赋值的操作由FindXXX.cmake模块完成。
Config模式：搜索XXX_DIR指定路径下的XXXConfig.cmake文件，执行该文件从而找到XXX库。其中具体查找库并给XXX_INCLUDE_DIRS和XXX_LIBRARIES两个变量赋值的操作由XXXConfig.cmake模块完成。

两种模式看起来似乎差不多，不过cmake默认采取Module模式，如果Module模式未找到库，才会采取Config模式。如果XXX_DIR路径下找不到XXXConfig.cmake文件，则会找/usr/local/lib/cmake/XXX/中的XXXConfig.cmake文件。总之，Config模式是一个备选策略。通常，库安装时会拷贝一份XXXConfig.cmake到系统目录中，因此在没有显式指定搜索路径时也可以顺利找到。

在我遇到的问题中，由于Caffe安装时没有安装到系统目录，因此无法自动找到CaffeConfig.cmake，我在CMakeLists.txt最前面添加了一句话之后就可以了。

 `set(Caffe_DIR /home/wjg/projects/caffe/build)   #添加CaffeConfig.cmake的搜索路径`

### add_definitions

代码中通过宏　USE_MACRO 作为区分．

．．．

＃ifdef USE_MACRO

．．．

＃endif

我们可以通过在项目中的CMakeLists.txt 中添加如下代码控制代码的开启和关闭．

```c
+ OPTION(USE_MACRO

+  "Build the project using macro"

+  OFF)

+ IF(USE_MACRO)

+  add_definitions("-DUSE_MACRO")

+ endif(USE_MACRO)
```

## 关于Windows下与Linux下文件编码格式的讨论

跨平台的程序从GitHub 上下载下来导入到 visual studio 经常报莫名奇怪的错误，经查发现是文件编码的问题。接下来详细记录一下这个问题：

首先，怎么查看Windows 下一个文件的编码格式呢？

很简单，就是用记事本打开并点击另存为就可以看到文件是什么格式了

![image-20200711210801609](https://i.loli.net/2020/07/11/Wy51jaBTCsgfItd.png)

上图中源文件是UTF-8的格式。而我们打开一个正常不乱码的文件查看发现是ANSI格式。不同的国家和地区制定了不同的标准，由此产生了 GB2312、GBK、GB18030、Big5、Shift_JIS 等各自的编码标准。这些使用多个字节来代表一个字符的各种汉字延伸编码方式，称为 ANSI 编码。在简体中文Windows操作系统中，ANSI 编码代表 GB2312编码；在繁体中文Windows操作系统中，ANSI编码代表Big5；

UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。

UTF-8 的编码规则很简单，只有二条：

1）对于单字节的符号，字节的第一位设为`0`，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。

2）对于`n`字节的符号（`n > 1`），第一个字节的前`n`位都设为`1`，第`n + 1`位设为`0`，后面字节的前两位一律设为`10`。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。

下表总结了编码规则，字母`x`表示可用编码的位。

```c
Unicode符号范围     |        UTF-8编码方式
(十六进制)        |              （二进制）
----------------------+---------------------------------------------
0000 0000-0000 007F | 0xxxxxxx
0000 0080-0000 07FF | 110xxxxx 10xxxxxx
0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
```

跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是`0`，则这个字节单独就是一个字符；如果第一位是`1`，则连续有多少个`1`，就表示当前字符占用多少个字节。

我们下载了VS 中的御用插件 ForceUTF-8 



 